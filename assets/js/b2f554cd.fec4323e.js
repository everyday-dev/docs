"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/9/21/avr-usb-made-simple-p2","metadata":{"permalink":"/blog/2023/9/21/avr-usb-made-simple-p2","source":"@site/blog/2023-9-21-avr-usb-made-simple-p2.mdx","title":"AVR USB Made Simple - Vendor Specific Control Transfers","description":"A multi-part introduction to USB on AVR microcontrollers. In Part 2 we cover the implementation of Vendor specific control transfers.","date":"2023-09-21T00:00:00.000Z","formattedDate":"September 21, 2023","tags":[{"label":"avr","permalink":"/blog/tags/avr"},{"label":"usb","permalink":"/blog/tags/usb"},{"label":"c","permalink":"/blog/tags/c"},{"label":"embedded","permalink":"/blog/tags/embedded"},{"label":"usb-made-simple","permalink":"/blog/tags/usb-made-simple"}],"readingTime":9.83,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"AVR USB Made Simple - Vendor Specific Control Transfers","authors":"stephen","tags":["avr","usb","c","embedded","usb-made-simple"],"draft":false,"keywords":["everydaydev","usb","avr","usb-made-simple"],"description":"A multi-part introduction to USB on AVR microcontrollers. In Part 2 we cover the implementation of Vendor specific control transfers.","image":"img/everydaydev_black_on_white_linkedin_520x272.png"},"nextItem":{"title":"AVR USB Made Simple - Enumeration","permalink":"/blog/2023/9/16/avr-usb-made-simple-p1"}},"content":"In our [previous post](/blog/2023/9/16/avr-usb-made-simple-p1) we implemented the bare minimum required to get a USB device to enumerate with the host and laid the groundwork\\nfor adding actual communications to our device. In this post we will do just that by adding support Vendor Specific control transfers, allowing a Host to Write and Read data from\\nthe device.\\n\x3c!--truncate--\x3e\\n\\nAs a reminder from the previous post, we are using the [atmega32u4 breakout board](/docs/atmega32u4_breakout/introduction), a breadboard friendly device with a USB 1.1 (Full-speed) interface.\\nThe code to follow along can be found on our [Github](https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw), just be sure to checkout the `control_vendor_rw`\\ntag.\\n\\nWithout further ado, let\'s get started!\\n\\n## Vendor Specific Control Transfers\\nVendor specific control transfers are exactly as they sound. They are Control transfers, sent via a Setup packet, that are specific to the vendor of the device. They are a great way to implement\\ndevice configuration, high level device control (on/off), status retrieval, and other low bandwidth items that don\'t require the overhead of a Bulk or Interrupt transfer.\\n\\nTo achieve this the host sends a setup packet with a `bRequestType` of `0x40` which indicates a vendor specific request. To clarify a bit, the `bRequestType` value of `0x40` not only indicates a\\nControl transfer but also that it is in the `OUT` direction, meaning Host to Device. The `bRequestType` value of `0xC0` indicates a Control transfer as well but in the `IN` direction, meaning Device\\nto Host. When implementing Vendor specific control transfers in our device firmware we don\'t actually care about the `IN` or `OUT` direction as we will be handling both in the same way. The `bRequestType` value of `0x40`\\nis all we need to know and then we will be using the `bRequest` value to determine if the transfer is a `Write` or `Read`. Let\'s see some code!\\n```c\\nelse if((bmRequestType & 0x60) == 0x40) { // Vendor specific request type\\n    switch(bRequest) {\\n        case 0x01:\\n\\n            // A packet was WRITTEN to us. Do something with the\\n            // wValue and wIndex values here if needed.\\n            // myVariable = wValue\\n\\n            // Reply with a ZLP\\n            UEINTX &= ~(1 << TXINI);\\n            // Wait for the bank to become ready again\\n            while (!(UEINTX & (1<<TXINI)));\\n            break;\\n\\n        case 0x02:\\n            // Some data was requested from us. We can see how much data\\n            // was requested from us using the wLength value. Load up\\n            // the requested data and send it back as the `DATA` phase\\n            for(uint16_t i = 0; i < wLength; i++) {\\n                UEDATX = i;\\n            }\\n\\n            // Clear the TXINI bit to initiate the transfer\\n            UEINTX &= ~(1 << TXINI);\\n            // Wait for the bank to become ready again\\n            while (!(UEINTX & (1<<TXINI)));\\n            break;\\n\\n        default:\\n            // Unsupported vendor specific request. Reply with a STALL\\n            UECONX |= (1 << STALLRQ);\\n            break;\\n    }\\n}\\n```\\n\\nAs you can see we add a new `else if` block to our `_processSetupPacket` function to check if the Vendor specific transfer type is set. From there we say that a `bRequest` value of `0x01` indicates the\\nhost is writing data to us (`OUT`), and a `bRequest` value of `0x02` indicates the host is requesting data from us (`IN`). Again to clarify, you could also implement two separate `else if` blocks for `0x40`\\nand `0xC0` to further separate out the `IN` and `OUT` directions but for our purposes we are just going to handle them the same way.\\n\\nThe handling itself is pretty straight forward: for a `Write` we store\\nthe provided `wValue` and then reply with a ZLP (Zero length packet) to acknowledge the write. A read is just as simple, we check the requested length set via the `wLength` parameter and then load up the\\ndata to send back to the host. Once the data is loaded we initiate the transfer. If the host requests more data than we have available we will just send back whatever we have.\\nCare should also be taken that all responses back to the Host fit within the defined packet size for your endpoint. Meaning you might need to break up your response into multiple packets if the requested\\n`wLength` is greater than the packet size.\\n\\n## Integrating into our main application\\nNow that we can read and write data to our device, how do we actually use it in our application? The first and simplest way is to just add your get/set functions directly into the new `if` statement for\\nhandling control transfers. This is fine for simple applications but we can do better. Let\'s add some hooks into our main application that will allow us to register functions to be called when a transfer is\\nreceived.\\n\\n### Creating the hooks\\nTo start we will add two new function types to our `usb.h` file. The first function type `usb_controlWrite_rx_cb_t` is a function that takes a single `uint16_t` parameter and returns nothing - this will be used for our `Write` callback, meaning it\'s called when the host\\nwrites data to us, and the value written is passed as the `rxData` variable. The second function type `usb_controlRead_tx_cb_t` is a function that takes a `uint8_t` pointer and a `uint16_t` parameter and returns\\na `uint16_t` - this will be used for our `Read` callback, meaning it\'s called when the host requests data from us, and the `txData` pointer is where we will write our data to send back to the host, the `requestedTxLen`\\nis the amount of data requested by the host. The return value of the function is the amount of data actually written to the `txData` buffer.\\n```c\\ntypedef void (*usb_controlWrite_rx_cb_t)(uint16_t rxData);\\ntypedef uint16_t (*usb_controlRead_tx_cb_t)(uint8_t *txData, const uint16_t requestedTxLen);\\n\\n```\\n\\nNow we have a set of callbacks that we can register with our USB library. First create two new variables in our `usb.c` file to store the callbacks:\\n```c\\nusb_controlWrite_rx_cb_t _setupWrite_cb = NULL;\\nusb_controlRead_tx_cb_t _setupRead_cb = NULL;\\n```\\n\\nLet\'s update our `usb_init` function to take these callbacks as parameters and store them in our new variables:\\n```c\\nvoid usb_init(usb_controlWrite_rx_cb_t onControlWriteCb, usb_controlRead_tx_cb_t onControlReadCb) {\\n    // Power-On USB pads regulator\\n    UHWCON |= (1 << UVREGE);\\n\\n    // VBUS int enable, VBUS pad enable, USB Controller enable\\n    USBCON |= (1 << USBE) | (1 << OTGPADE) | (1 << FRZCLK);\\n\\n    // Toggle the FRZCLK to get WAKEUP IRQ\\n    USBCON &= ~(1 << FRZCLK);\\n    USBCON |= (1 << FRZCLK);\\n\\n    // Set the PLL input divisor to be 1:2 since we have\\n    // at 16MHz input (we want 8MHz output on the PLL)\\n    PLLCSR |= (1 << PINDIV);\\n\\n    // Default USB postscaler is fine as it generates\\n    // the 48Mhz clock from the 8Mhz PLL input by default\\n\\n    // Start the PLL\\n    PLLCSR |= (1 << PLLE);\\n\\n    // Wait for the PLL to lock\\n    while (!(PLLCSR &(1<<PLOCK)));\\n\\n    // Leave power saving mode\\n    USBCON &= ~(1 << FRZCLK);\\n\\n    // Store our CB if we received one\\n    if(onControlWriteCb != NULL) {\\n        _setupWrite_cb = onControlWriteCb;\\n    }\\n\\n    if(onControlReadCb != NULL) {\\n        _setupRead_cb = onControlReadCb;\\n    }\\n\\n    // Attach the device by clearing the detach bit\\n    // This is acceptable in the case of a bus-powered device\\n    // otherwise you would initiate this step based on a\\n    // VBUS detection.\\n    UDCON &= ~(1 << DETACH);\\n\\n    // Enable the USB Reset IRQ. This IRQ fires when the\\n    // host sends a USB reset to the device to kickoff\\n    // USB enumeration. Init of the USB will continue in the\\n    // ISRs when the reset signal is received.\\n    UDIEN |= (1 << EORSTE);\\n}\\n```\\n\\nNext, we need to add our callback definitions in `main.c` and pass them as parameters to our `usb_init` call.\\n```c\\n\\nvoid onUsbControlWrite(uint16_t rxData) {\\n    // Do something with the rxData that was just written to us from the Host\\n}\\n\\nuint16_t onUsbControlRead(uint8_t *txData, const uint16_t requestedTxLen) {\\n    uint16_t txLen = 0;\\n\\n    // Load up data into the txData buffer to send back to the host.\\n    // Make sure to also update txLen with the amount of data that we load\\n\\n    return txLen;\\n}\\n\\nint main(void) {\\n    // Set our LED port as an output\\n    LED_STAT_DDR |= (1 << LED_STAT_PIN);\\n\\n    // Init USB and provide it our callback function\\n    // to be called when data is received via a\\n    // Control Write transfer\\n    usb_init(onUsbControlWrite, onUsbControlRead);\\n\\n    // Enable global interrupts\\n    sei();\\n\\n    while(1) {\\n        // Do nothing\\n    }\\n}\\n```\\n\\nLast, we need to call the callbacks from our `usb.c` file when a control transfer is received. Let\'s update our `else if` block for handling control transfers to look like this:\\n```c\\nelse if((bmRequestType & 0x60) == 0x40) { // Vendor specific request type\\n    switch(bRequest) {\\n        case 0x01:\\n            // If we have a callback stored, call it with the value\\n            if(_setupWrite_cb != NULL) {\\n                _setupWrite_cb(wValue);\\n            }\\n\\n            // Reply with a ZLP\\n            UEINTX &= ~(1 << TXINI);\\n            // Wait for the bank to become ready again\\n            while (!(UEINTX & (1<<TXINI)));\\n            break;\\n\\n        case 0x02:\\n            if(_setupRead_cb != NULL) {\\n                // Call our callback to get the data to send back\\n                uint16_t txLen = _setupRead_cb(_setup_read_buff,\\n                    (wLength > CONTROL_EP_BANK_SIZE ?\\n                        CONTROL_EP_BANK_SIZE :\\n                        wLength));\\n                // Send the data back to the host\\n                for(uint16_t i = 0; i < txLen; i++) {\\n                    UEDATX = _setup_read_buff[i];\\n                }\\n                // Clear the TXINI bit to initiate the transfer\\n                UEINTX &= ~(1 << TXINI);\\n                // Wait for the bank to become ready again\\n                while (!(UEINTX & (1<<TXINI)));\\n            }\\n            else {\\n                // No callback was provided so\\n                // reply with a stall\\n                UECONX |= (1 << STALLRQ);\\n            }\\n            break;\\n\\n        default:\\n            // Unsupported vendor specific request. Reply with a STALL\\n            UECONX |= (1 << STALLRQ);\\n            break;\\n    }\\n}\\n```\\n\\nNow when a control transfer is received we will call the appropriate callback if one was provided. Next let\'s fill out the callbacks in our application to actually do something with the\\ndata that is received or requested.\\n\\n### Using the callbacks\\nFor the `Write` callback, we are going to store the received data and then handle it in the main loop. We don\'t want to do much more than that since these callbacks are actually being\\ncalled from the ISR in `usb.c`. We should be as quick and efficient as possible, offloading any heavy lifting to the main loop. In our example we are going to be using the received value\\nas an LED state, which we will update in the main loop. In the `Read` callback we are going to load up a single value of `0x03` into the buffer and return with a value of `0x01` since we\\nloaded a single byte. Let\'s see the code:\\n```c\\nuint16_t my_led_state = 0;\\n\\nvoid onUsbControlWrite(uint16_t rxData) {\\n    my_led_state = rxData;\\n}\\n\\nuint16_t onUsbControlRead(uint8_t *txData, const uint16_t requestedTxLen) {\\n    uint16_t txLen = 1;\\n\\n    txData[0] = 0x03;\\n\\n    return txLen;\\n}\\n\\nint main(void) {\\n    // Set our LED port as an output\\n    LED_STAT_DDR |= (1 << LED_STAT_PIN);\\n\\n    // Init USB and provide it our callback function\\n    // to be called when data is received via a\\n    // Control Write transfer\\n    usb_init(onUsbControlWrite, onUsbControlRead);\\n\\n    // Enable global interrupts\\n    sei();\\n\\n    while(1) {\\n        if(my_led_state) {\\n            LED_STAT_PORT |= (1 << LED_STAT_PIN);\\n        }\\n        else {\\n            LED_STAT_PORT &= ~(1 << LED_STAT_PIN);\\n        }\\n    }\\n}\\n```\\n\\nThat\'s it, we\'re ready to connect with a Host and send vendor specific data!\\n\\n## Testing it out\\nTo test out our new Vendor specific control transfers we have three languages to pick from: C, Python, and NodeJS. Each of these languages have an example for both the `Write` and `Read` transfers.\\n- [C example](https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw/host/c)\\n- [NodeJS example](https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw/host/nodejs)\\n- [Python example](https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw/host/python)\\n\\nAt each link you\'ll find instructions for building and using the applications.\\n\\n## Conclusion\\nThat\'s it, we now have a working USB device that can be controlled via Vendor specific control transfers! In coming posts we will cover the Interrupt, Bulk and Isochronous transfer types, where we will\\ntalk about their key differences and when to use each one. We will also cover how to implement them in our device firmware. Stay tuned!"},{"id":"/2023/9/16/avr-usb-made-simple-p1","metadata":{"permalink":"/blog/2023/9/16/avr-usb-made-simple-p1","source":"@site/blog/2023-9-16-avr-usb-made-simple-p1.mdx","title":"AVR USB Made Simple - Enumeration","description":"A multi-part introduction to USB on AVR microcontrollers. Part 1 covers the basics of USB and how to get a device enumerating in an OS.","date":"2023-09-16T00:00:00.000Z","formattedDate":"September 16, 2023","tags":[{"label":"avr","permalink":"/blog/tags/avr"},{"label":"usb","permalink":"/blog/tags/usb"},{"label":"c","permalink":"/blog/tags/c"},{"label":"embedded","permalink":"/blog/tags/embedded"},{"label":"usb-made-simple","permalink":"/blog/tags/usb-made-simple"}],"readingTime":14.765,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"AVR USB Made Simple - Enumeration","authors":"stephen","tags":["avr","usb","c","embedded","usb-made-simple"],"draft":false,"keywords":["everydaydev","usb","avr","usb-made-simple"],"description":"A multi-part introduction to USB on AVR microcontrollers. Part 1 covers the basics of USB and how to get a device enumerating in an OS.","image":"img/everydaydev_black_on_white_linkedin_520x272.png"},"prevItem":{"title":"AVR USB Made Simple - Vendor Specific Control Transfers","permalink":"/blog/2023/9/21/avr-usb-made-simple-p2"},"nextItem":{"title":"We\'re back - and we have a new name","permalink":"/blog/2023/6/30/rebranding"}},"content":"In this multi-part series, we will explore USB implementation on AVR microcontrollers, starting with the basics of USB enumeration. USB can be found all around us in our everyday\\nlives. It\'s in our phones, our computers, our cars, and even our home appliances. It\'s a ubiquitous standard that has been around for decades and is still going strong. However\\nwe often take it for granted as engineers and developers. Silicon vendors have made it so easy to get a device up and running with USB via their libraries and examples\\nthat we don\'t often think about what\'s going on under the hood.\\n\x3c!--truncate--\x3e\\n\\nThis series of posts is going attempt to demystify USB and show how to implement it in a bare-metal environment. For these posts I\'ll be using the\\n[atmega32u4 breakout board](/docs/atmega32u4_breakout/introduction) which has a USB 1.1 (Fullspeed) interface and is breadboard friendly. The simple register\\nbased setup of the AVR microcontrollers makes it a great platform to learn the basics of USB with as little abstraction as possible so not to many of the details\\nare hidden from us. It\'s worth mentioning that there is a very popular library called [LUFA](https://github.com/abcminiuser/lufa) that implements a USB stack for\\nAVR microcontrollers. It\'s a great library and easy to use but it\'s also a bit of a black box.\\n\\nYou can [find the code to follow along on our Github.](https://github.com/everyday-dev/avr-usb-made-simple/tree/control_basic_enum) Just be sure you are looking at the\\n`control_basic_enum` tag. The repository is based on our [avr-cmake-template](docs/avr-cmake-template) and built using the `avr-gcc` toolchain.\\n\\n## USB basics\\nA great place to learn the basics of USB communication is this [USB Made Simple](https://www.usbmadesimple.co.uk/index.html) site. It starts out giving a\\nhigh-level overview of the USB standard and then goes into the details of the protocol. I highly recommend reading through the site at least up to Part 4 to better\\nunderstand the concepts I\'ll be talking about in this post.\\n\\n## USB Enumeration\\nThe bare minimum functionality of a USB device is to enumerate with the host which is the process of the host collecting information about the device and it\'s capabilities.\\nThe host does so by initiating `Control` transfers to the USB endpoint `0`, querying information such as the devices product name, manufacturer, serial number and supported\\ninterfaces. The host will then use this information to load the appropriate drivers to continue device\\nspecific communication.\\n\\n## AVR USB\\nOur objective in this post is not to implement any host driver functionality but to get our device to enumerate with the host. When we are all done the kernel log output on a\\nLinux machine should look like this when the device is plugged in:\\n```bash\\n[986045.250483] usb 3-8.2: new full-speed USB device number 23 using xhci_hcd\\n[986045.401173] usb 3-8.2: New USB device found, idVendor=dead, idProduct=beef, bcdDevice= 0.01\\n[986045.401185] usb 3-8.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3\\n[986045.401189] usb 3-8.2: Product: avr usb made simple\\n[986045.401192] usb 3-8.2: Manufacturer: everydaydev\\n[986045.401195] usb 3-8.2: SerialNumber: 2023\\n```\\n\\n### USB Init\\nOur first step is to create our USB init function. This will handle setting up the USB peripheral power rails, configuring the PLL for our clock source, and enabling\\nany required interrupts. Note: In this example we are using the external 16MHz crystal on the atmega32u4 breakout board. If you are using a different board or a different clock\\nconfiguration you will need to adjust the PLL. The main objective is to get a 48MHz clock source for the USB peripheral.\\n```c\\nvoid usb_init(void) {\\n    // Power-On USB pads regulator\\n    UHWCON |= (1 << UVREGE);\\n\\n    // VBUS int enable, VBUS pad enable, USB Controller enable\\n    USBCON |= (1 << USBE) | (1 << OTGPADE) | (1 << FRZCLK);\\n\\n    // Toggle the FRZCLK to get WAKEUP IRQ\\n    USBCON &= ~(1 << FRZCLK);\\n    USBCON |= (1 << FRZCLK);\\n\\n    // Set the PLL input divisor to be 1:2 since we have\\n    // at 16MHz input (we want 8MHz output on the PLL)\\n    PLLCSR |= (1 << PINDIV);\\n\\n    // Default USB postscaler is fine as it generates\\n    // the 48Mhz clock from the 8Mhz PLL input by default\\n\\n    // Start the PLL\\n    PLLCSR |= (1 << PLLE);\\n\\n    // Wait for the PLL to lock\\n    while (!(PLLCSR &(1<<PLOCK)));\\n\\n    // Leave power saving mode\\n    USBCON &= ~(1 << FRZCLK);\\n\\n    // Attach the device by clearing the detach bit\\n    // This is acceptable in the case of a bus-powered device\\n    // otherwise you would initiate this step based on a\\n    // VBUS detection.\\n    UDCON &= ~(1 << DETACH);\\n\\n    // Enable the USB Reset IRQ. This IRQ fires when the\\n    // host sends a USB reset to the device to kickoff\\n    // USB enumeration. Init of the USB will continue in the\\n    // ISRs when the reset signal is received.\\n    UDIEN |= (1 << EORSTE);\\n}\\n```\\n\\n### USB Interrupts\\nA crucial part of USB communication is the handling of interrupts as all communication will be initiated through them. The AVR USB peripheral has two categories of interrupts: The `GEN` interrupt vector is where information such as bus resets and VBUS changes are\\nhandled and the `COM` interrupt vector is where all USB communication is handled. This includes `Control`, `Bulk`, `Interrupt`, and `Isochronous` transfers.\\nOur basic ISRs to achieve USB enumeration look like this:\\n```c\\nISR(USB_GEN_vect) {\\n    // Check if a USB reset sequence was received from the host\\n    if (UDINT & (1<<EORSTI)) {\\n        // Clear the interrupt flag\\n        UDINT &= ~(1<<EORSTI);\\n        // Init our device endpoints\\n        _endpoint_init();\\n        // Enable our Setup RX interrupt. This causes\\n        // an ISR to fire when a Setup packet is received\\n        UEIENX |= (1<<RXSTPE);\\n    }\\n}\\n\\nISR(USB_COM_vect) {\\n    // Check which endpoint caused the interrupt\\n    switch (UEINT) {\\n        case (1<<EPINT0):\\n            // Select EP 0 before checking the interrupt register\\n            UENUM = 0;\\n            // Check if we received a Setup packet\\n            if (UEINTX & (1<<RXSTPI)) {\\n                // Handle the setup packet\\n                _processSetupPacket();\\n            }\\n            break;\\n\\n        default:\\n            break;\\n    }\\n}\\n```\\n\\nAs you can see we are using the `GEN` vector to detect the `End Of Reset` interrupt. This occurs when the host resets a device and is wanting\\nthe device to begin the enumeration process. When this interrupt fires we then initialize our endpoints - We\'ll come back to that later. Inside the `COM` vector\\nyou can see we determine which Endpoint caused a communications interrupt (Control transfers always use Endpoint 0) and then we act on what type of communication\\ninterrupt was triggered. In our bare example we are only looking for `Setup` packets. These are the packets that the host sends to the device to query information.\\nWe will dive into our `Setup` packet handler shortly.\\n\\n### Endpoint Initialization\\nEndpoints are \\"pipes\\" that data is sent and received in and must be initialized with a bank size indicating how much data can be written to/from the pipe during any transfer. In our bare enumeration example we will be implementing just the our Control endpoint (EP0) so we can handle Setup packets from the Host. We start by selecting EP0, resetting its FIFO and enabling it in the OUT direction. Once complete,\\nwe enable the endpoint interrupt which allow us to detect when a Setup packet is received.\\n```c\\nbool _endpoint_init(void) {\\n    // Select Endpoint 0\\n    UENUM = 0x00;\\n    // Reset the endpoint fifo\\n    UERST = 0x7F;\\n    UERST = 0x00;\\n    // Enable the endpoint\\n    UECONX |= (1 << EPEN);\\n    // Configure endpoint as Control with OUT direction\\n    UECFG0X = 0;\\n    // Configure endpoint size\\n    UECFG1X = (1 << EPSIZE1) | (1 << EPSIZE0);\\n    // Allocate the endpoint buffers\\n    UECFG1X |= (1 << ALLOC);\\n    // Enable the endpoint interrupt\\n    UEIENX |= (1 << RXSTPE) | (1 << RXOUTE);\\n    // Check if endpoint configuration is ok\\n    return((UESTA0X & (1 << CFGOK)));\\n}\\n```\\n\\n### Setup Packet Handling\\nThe final piece (and most important) is the handling of the Setup packet. This is where the host will query information about the device, set the bus address, and set the\\ndevice configuration. The received Setup packet is 8 bytes long and contains information such as the request type, request, value, index, and length. The first step is to read the 8 bytes\\nfrom the FIFO and then acknowledge the packet by clearing the RXSTPI bit. We then check the request type to determine what type of request was sent. In our example we are only handling\\nthe `Standard` request type. From here you can see we handle `GET_STATUS`, `SET_ADDRESS`, and `GET_DESCRIPTOR`, and `SET_CONFIGURATION` requests from the Host allowing it to fully configure and enumerate the device in the OS.\\n```c\\nstatic void  _processSetupPacket(void) {\\n    // Read the 8 bytes from the setup packet. Depending on the type of request\\n    // each value may have a different use/meaning. Reference \\"The SETUP Packet\\" section\\n    // of https://www.usbmadesimple.co.uk/ums_4.htm for more information on what each byte\\n    // means for a given request type.\\n    uint8_t bmRequestType = UEDATX;\\n    uint8_t bRequest = UEDATX;\\n    uint8_t wValue_l = UEDATX;\\n    uint8_t wValue_h = UEDATX;\\n    uint8_t wIndex_l = UEDATX;\\n    uint8_t wIndex_h = UEDATX;\\n    uint8_t wLength_l = UEDATX;\\n    uint8_t wLength_h = UEDATX;\\n    uint16_t descriptorLength = 0;\\n\\n    // Ack the received setup package by clearing the RXSTPI bit\\n    UEINTX &= ~(1 << RXSTPI);\\n\\n    if ((bmRequestType & 0x60) == 0) { // Standard request type\\n        switch (bRequest) {\\n            case GET_STATUS:\\n                // Reply with 16 bits for our status. We are self powered, no remote-wakeup\\n                // and we are not halted.\\n                UEDATX = 0;\\n                UEDATX = 0;\\n                // Clear the TXINI bit to initiate the transfer\\n                UEINTX &= ~(1 << TXINI);\\n                // Wait for ZLP from host\\n                while (!(UEINTX & (1 << RXOUTI)));\\n                // Clear the RXOUTI bit to acknowledge the packet\\n                UEINTX &= ~(1 << RXOUTI);\\n                break;\\n\\n            case SET_ADDRESS:\\n                // Section 22.7 of https://ww1.microchip.com/downloads/en/devicedoc/atmel-7766-8-bit-avr-atmega16u4-32u4_datasheet.pdf\\n                // Device stores received address in the UDADDR register.\\n                UDADDR = (wValue_l & 0x7F);\\n                // Device should then respond with a ZLP to acknowledge the request\\n                UEINTX &= ~(1 << TXINI);\\n                // Wait for the bank to become ready again (TIXINI set)\\n                while (!(UEINTX & (1<<TXINI)));\\n                // After sending the ZLP, the device should apply the address by setting the ADDEN bit\\n                UDADDR |= (1 << ADDEN);\\n                break;\\n\\n            case GET_DESCRIPTOR:\\n                switch (wValue_h) {\\n                    case DESC_DEVICE:\\n                        // Retrieve the Device desc length from the descriptor\\n                        // structure. This is the first byte of the descriptor.\\n                        descriptorLength = pgm_read_byte(&DeviceDescriptor[0]);\\n                        // Send it back to the host\\n                        _sendDescriptor((uint8_t*) DeviceDescriptor, descriptorLength);\\n                        break;\\n\\n                    case DESC_CONFIG:\\n                        // The Host will first request the base Config descriptor which is of length\\n                        // 9 to determine how many interfaces are available.\\n                        // However, once the host determines how many interfaces are available it will then\\n                        // do another Config descriptor read with the full length of the descriptor.\\n                        descriptorLength = wLength_l + (wLength_h << 8);\\n                        // Send the descriptor with the requested length\\n                        _sendDescriptor((uint8_t*)ConfigDescriptor, descriptorLength);\\n                        break;\\n\\n                    case DESC_STRING:\\n                        switch (wValue_l) {\\n                            case DESC_STRING_LANG:\\n                                // Retrieve the Language desc length from the descriptor\\n                                // structure. This is the first byte of the descriptor.\\n                                descriptorLength = pgm_read_byte(&LanguageDescriptor[0]);\\n                                // Send it back to the host\\n                                _sendDescriptor((uint8_t*) LanguageDescriptor,descriptorLength);\\n                                break;\\n\\n                            case DESC_STRING_MANUF:\\n                                // Retrieve the Manufacturer string desc length from the descriptor\\n                                // structure. This is the first byte of the descriptor.\\n                                descriptorLength = pgm_read_byte(&ManufacturerStringDescriptor[0]);\\n                                // Send it back to the host\\n                                _sendDescriptor((uint8_t*) ManufacturerStringDescriptor,descriptorLength);\\n                                break;\\n\\n                            case DESC_STRING_PROD:\\n                                // Retrieve the Product string desc length from the descriptor\\n                                // structure. This is the first byte of the descriptor.\\n                                descriptorLength = pgm_read_byte(&ProductStringDescriptor[0]);\\n                                // Send it back to the host\\n                                _sendDescriptor((uint8_t*) ProductStringDescriptor,descriptorLength);\\n                                break;\\n\\n                            case DESC_STRING_SERIAL:\\n                                // Retrieve the Serial string desc length from the descriptor\\n                                // structure. This is the first byte of the descriptor.\\n                                descriptorLength = pgm_read_byte(&SerialStringDescriptor[0]);\\n                                // Send it back to the host\\n                                _sendDescriptor((uint8_t*) SerialStringDescriptor,descriptorLength);\\n                                break;\\n\\n                            default:\\n                                break;\\n                        }\\n                        break;\\n\\n                    default:\\n                        break;\\n                }\\n                break;\\n\\n            case SET_CONFIGURATION:\\n                // Select EP 0\\n                UENUM = 0;\\n                // Reply with a ZLP to acknowledge the request\\n                UEINTX &= ~(1 << TXINI);\\n                // Wait for the bank to be ready again\\n                while (!(UEINTX & (1<<TXINI)));\\n                break;\\n\\n            default:\\n                // Invalid request was sent. Reply with a STALl\\n                UECONX |= (1 << STALLRQ);\\n                break;\\n        }\\n    }\\n    else if((bmRequestType & 0x60) == 0x40) { // Vendor specific request type\\n        switch(bRequest) {\\n            default:\\n                // Unsupported vendor specific request. Reply with a STALL\\n                UECONX |= (1 << STALLRQ);\\n                break;\\n        }\\n    }\\n    else { // Invalid request type\\n        // Reply with a STALL\\n        UECONX |= (1 << STALLRQ);\\n    }\\n}\\n```\\n\\nThe last piece is our function for sending descriptors back to the host. This is pretty straight forward but it should be noted that we take care to\\nbreak up the descriptor into 8 byte chunks. This is because the host will only read 8 bytes at a time.\\n\\n```c\\nstatic void _sendDescriptor(const uint8_t* descriptor, uint16_t length) {\\n    // See section 22.12.2 of https://ww1.microchip.com/downloads/en/devicedoc/atmel-7766-8-bit-avr-atmega16u4-32u4_datasheet.pdf\\n    // for an illustration of the \\"Control Read\\" process. Specifically the \\"DATA\\" and \\"STATUS\\"\\n    // portion of the timing diagram are handled here.\\n\\n    // We are going to chunk the descriptor into 8 byte packets. Looping until we have finished\\n    for(uint16_t i = 1; i <= length; i++) {\\n        if(UEINTX & (1 << RXOUTI)) {\\n            // We received an OUT packet which means\\n            // the HOST wants us to abort.\\n            // Clear the RXOUTI bit to acknowledge the packet\\n            UEINTX &= ~(1 << RXOUTI);\\n            return;\\n        }\\n\\n        // Load the next byte from our descriptor\\n        UEDATX = pgm_read_byte(&descriptor[i-1]);\\n        // If our packet is full\\n        if(((i%8) == 0)) {\\n            // Clear the TXINI bit to initiate the transfer\\n            UEINTX &= ~(1 << TXINI);\\n            // Wait for transmission to complete (TXINI set) or\\n            // the HOST to abort (RXOUTI set)\\n            while (!(UEINTX & ((1 << RXOUTI) | (1<<TXINI))));\\n        }\\n    }\\n    // Go ahead and transmit the remaining data (if there is any) if the HOST\\n    // hasn\'t asked us to abort\\n    if((!(UEINTX & (1 << RXOUTI)))) {\\n        // Clear the TXINI bit to initiate the transfer\\n        // to send the remaining data we may have queued up\\n        UEINTX &= ~(1 << TXINI);\\n        // Wait for the ACK back from the host (RXOUTI set)\\n        while (!(UEINTX & (1 << RXOUTI)));\\n    }\\n\\n    // Clear the RXOUTI bit to acknowledge the packet\\n    UEINTX &= ~(1 << RXOUTI);\\n}\\n```\\n\\n### Descriptors\\nUSB Descriptors are a crucial part of USB enumeration and they are the mechanism by which the host learns about the device and it\'s capabilities. The descriptors are a data structure\\nthat is sent to the host when requested via a `GET_DESCRIPTOR` request. The most common descriptors are `Device`, `Configuration`, `Interface`, `Endpoint`, and `String` descriptors.\\nThe host will request these descriptors, learning a bit more about the device each time, and use that information to inform it\'s next decision which might be to request more information\\nor begin loading a driver for the device. Our descriptors are pretty basic at the moment since we don\'t actually implement any functionality on the device. Our basic descriptors and\\ncommented explanations are below.\\n```c\\n// USB descriptors (example, replace with your own)\\nconst uint8_t PROGMEM DeviceDescriptor[] = {\\n    0x12,       // bLength\\n    0x01,       // bDescriptorType (Device == 1)\\n    0x01, 0x01, // bcdUSB (USB 1.1 for Full Speed)\\n    0x00,       // bDeviceClass (0 for composite device)\\n    0x00,       // bDeviceSubClass\\n    0x00,       // bDeviceProtocol\\n    0x08,       // bMaxPacketSize0 (8 bytes)\\n    0xad, 0xde, // idVendor (0xdead)\\n    0xef, 0xbe, // idProduct (0xbeef)\\n    0x01, 0x00, // bcdDevice (Device version)\\n    0x01,       // iManufacturer (Index of manufacturer string descriptor)\\n    0x02,       // iProduct (Index of product string descriptor)\\n    0x03,       // iSerialNumber (Index of serial number string descriptor)\\n    0x01        // bNumConfigurations (Number of configurations)\\n};\\n\\nconst uint8_t PROGMEM ConfigDescriptor[] = {\\n    0x09,       // bLength\\n    0x02,       // bDescriptorType (Configuration == 2)\\n    0x12, 0x00, // wTotalLength (Total length of configuration descriptor and sub-descriptors)\\n    0x01,       // bNumInterfaces (Number of interfaces in this configuration)\\n    0x01,       // bConfigurationValue (Configuration value, must be 1)\\n    0x00,       // iConfiguration (Index of string descriptor for this configuration)\\n    0x80,       // bmAttributes (Bus-powered, no remote wakeup)\\n    0xFA,       // bMaxPower (Maximum power consumption, 500mA)\\n    0x09,       // bLength = 0x09, length of descriptor in bytes\\n    0x04,       // bDescriptorType = 0x04, (Interface == 4)\\n    0x00,       // bInterfaceNumber = 0;\\n    0x00,       // bAlternateSetting = 0;\\n    0x00,       // bNumEndpoints = USB_Endpoints;\\n    0xFF,       // bInterfaceClass = 0xFF, classcode: custome (0xFF)\\n    0xFF,       // bInterfaceSubClass = 0xFF, subclasscode: custome (0xFF)\\n    0xFF,       // bInterfaceProtocol = 0xFF, protocoll code: custome (0xFF)\\n    0x00        // iInterface = 0, Index for string descriptor interface\\n};\\n\\nconst uint8_t PROGMEM LanguageDescriptor[] = {\\n    0x04,     // bLength - Length of sting language descriptor including this byte\\n    0x03,     // bDescriptorType - (String == 3)\\n    0x09,0x04 // wLANGID[x] - (0x0409 = English USA)\\n};\\n\\nconst uint8_t PROGMEM ManufacturerStringDescriptor[] = {\\n    24,         // bLength - Length of string descriptor (including this byte)\\n    0x03,       // bDescriptorType - (String == 3)\\n    \'e\',0x00,   // bString - Unicode Encoded String (16 Bit)\\n    \'v\',0x00,\\n    \'e\',0x00,\\n    \'r\',0x00,\\n    \'y\',0x00,\\n    \'d\',0x00,\\n    \'a\',0x00,\\n    \'y\',0x00,\\n    \'d\',0x00,\\n    \'e\',0x00,\\n    \'v\',0x00\\n};\\n\\nconst uint8_t PROGMEM ProductStringDescriptor[] = {\\n    40,         // bLength - Length of string descriptor (including this byte)\\n    0x03,       // bDescriptorType - (String == 3)\\n    \'a\',0x00,   // bString - Unicode Encoded String (16 Bit)\\n    \'v\',0x00,\\n    \'r\',0x00,\\n    \' \',0x00,\\n    \'u\',0x00,\\n    \'s\',0x00,\\n    \'b\',0x00,\\n    \' \',0x00,\\n    \'m\',0x00,\\n    \'a\',0x00,\\n    \'d\',0x00,\\n    \'e\',0x00,\\n    \' \',0x00,\\n    \'s\',0x00,\\n    \'i\',0x00,\\n    \'m\',0x00,\\n    \'p\',0x00,\\n    \'l\',0x00,\\n    \'e\',0x00,\\n};\\n\\nconst uint8_t PROGMEM SerialStringDescriptor[] = {\\n    0x0A,       // bLength - Length of string descriptor (including this byte)\\n    0x03,       // bDescriptorType - (String == 3)\\n    \'2\',0x00,   // bString - Unicode Encoded String (16 Bit)\\n    \'0\',0x00,\\n    \'2\',0x00,\\n    \'3\',0x00\\n};\\n```\\n\\n## Conclusion\\nThat\'s it! We now have a device that will enumerate with the host and provide basic information about itself. In the next post we will add a bit more functionality\\nto our device by adding handling for \\"Vendor specific\\" control transfers allowing us to read/write small amounts of data from/to the device. We will also demonstrate\\na couple of different ways to write data to a USB device via Control transfers from a Host OS using C, NodeJS, and Python."},{"id":"/2023/6/30/rebranding","metadata":{"permalink":"/blog/2023/6/30/rebranding","source":"@site/blog/2023-6-30-rebranding.mdx","title":"We\'re back - and we have a new name","description":"greatlakesdev has rebranded to everyday dev.","date":"2023-06-30T00:00:00.000Z","formattedDate":"June 30, 2023","tags":[{"label":"introduction","permalink":"/blog/tags/introduction"}],"readingTime":0.765,"hasTruncateMarker":false,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"We\'re back - and we have a new name","authors":"stephen","tags":["introduction"],"draft":false,"keywords":["everydaydev","rebranding","new name"],"description":"greatlakesdev has rebranded to everyday dev.","image":"img/everydaydev_black_on_white_linkedin_520x272.png"},"prevItem":{"title":"AVR USB Made Simple - Enumeration","permalink":"/blog/2023/9/16/avr-usb-made-simple-p1"},"nextItem":{"title":"Project Spotlight \ud83d\udd26 KiCAD Template","permalink":"/blog/2023/1/23/spotlight-kicad-template"}},"content":"After a prolonged hiatus, we\'re excited to be back writing blog posts again! A lot has changed since our last post, including\\nname! We\'ve rebranded from greatlakes dev to everyday\u26a1dev! We believe this new name aligns with how we feel: engineering isn\'t just a job -\\nit\'s our passion. We thrive on the joy of creating innovative solutions day in and day out. We know a lot of folks can sympathize with this feeling and we hope to build a community around this.\\n\\nSo what\'s next?\\n\\nOur mission is to share knowledge and help others grow in their personal and professional\\nembedded journeys. In pursuit of our mission, we plan to post content on a more regular basis, including deep dives for embedded concepts and creating more open source hardware and firmware projects.\\nStay up to date by following the blog for updates.\\n\\nWant to jump in?\\n\\nCheck out our [\u26a1DEV101](/blog/tags/dev-101) series now."},{"id":"/2023/1/23/spotlight-kicad-template","metadata":{"permalink":"/blog/2023/1/23/spotlight-kicad-template","source":"@site/blog/2023-1-23-spotlight-kicad-template.mdx","title":"Project Spotlight \ud83d\udd26 KiCAD Template","description":"Product Spotlight for the KiCAD project template adding automated releases","date":"2023-01-23T00:00:00.000Z","formattedDate":"January 23, 2023","tags":[{"label":"spotlight","permalink":"/blog/tags/spotlight"}],"readingTime":0.92,"hasTruncateMarker":false,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"Project Spotlight \ud83d\udd26 KiCAD Template","authors":"stephen","tags":["spotlight"],"draft":false,"keywords":["kicad","template","spotlight","everydaydev"],"description":"Product Spotlight for the KiCAD project template adding automated releases"},"prevItem":{"title":"We\'re back - and we have a new name","permalink":"/blog/2023/6/30/rebranding"},"nextItem":{"title":"New OSHWA certifications received!","permalink":"/blog/2023/1/12/oshwa-certification"}},"content":"The [KiCAD project template](https://github.com/everyday-dev/kicad-project-template) just got even easier to use! The [docs](/docs/kicad-project-template) have had a new addition made\\nfor the template explaining how to configure and get designing quickly. It also documents several of the new features added that will increase the quality of life when developing\\nKiCAD projects. To summarize - the template is pre-configured with the smallest possible tolerances while staying in the PCBWay standard stackup, allowing the most versatility while\\ndesigning without costing too much money. A ```util/``` folder has been added with a few python scripts making it easier to generate useful BOMs from a somewhat finicky system that\\nKiCAD currently uses. Lastly a Github workflow has been added to automate the release process outputing your schematic, ```.step``` file of the board, Gerbers and your BOM. All of these\\nartifacts are automatically uploaded to a Github release which has been tagged with the revision found in your PCB design files.\\n\\n- \ud83d\udcda [Documentation](/docs/kicad-project-template)\\n- \ud83c\udfd7\ufe0f [Template](https://github.com/everyday-dev/kicad-project-template)\\n\\nThese features and workflows have been tested and documented but please reach out and create an issue if you have any trouble.\\n\\nHappy tinkering!"},{"id":"/2023/1/12/oshwa-certification","metadata":{"permalink":"/blog/2023/1/12/oshwa-certification","source":"@site/blog/2023-1-12-oshwa-certification/index.mdx","title":"New OSHWA certifications received!","description":"everyday\u26a1dev receives OSHWA certification for breadboard-io and atmega32u4_breakout boards","date":"2023-01-12T00:00:00.000Z","formattedDate":"January 12, 2023","tags":[{"label":"certification","permalink":"/blog/tags/certification"},{"label":"oshwa","permalink":"/blog/tags/oshwa"}],"readingTime":0.305,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"New OSHWA certifications received!","authors":"stephen","tags":["certification","oshwa"],"keywords":["oshwa","certification","everydaydev"],"description":"everyday\u26a1dev receives OSHWA certification for breadboard-io and atmega32u4_breakout boards"},"prevItem":{"title":"Project Spotlight \ud83d\udd26 KiCAD Template","permalink":"/blog/2023/1/23/spotlight-kicad-template"},"nextItem":{"title":"DEV101 \u26a1 Creating user interaction animations","permalink":"/blog/2023/1/10/creating-user-interaction-animations"}},"content":"During the holdiays we submitted the [breadboard-io](/docs/breadboard-io) and [atmega32u4 breakout](/docs/atmega32u4_breakout/introduction) boards for\\ncertification and we\'ve just heard back - we\'ve been certified! This will definitely be the first of many as we continue to create more projects\\nand share them with everyone.\\n\\n![img](/img/oshw_cert_breadboardio.svg)\\n![img](/img/oshw_cert_atmega32u4_breakout.svg)\\n\\n\x3c!--truncate--\x3e\\n\\nOur new certs can be found in the [OSHWA registry](https://certification.oshwa.org/list):\\n- [[US002159] breadboard-io](https://certification.oshwa.org/us002159.html)\\n- [[US002160] atmeag32u4_breakout](https://certification.oshwa.org/us002160.html)"},{"id":"/2023/1/10/creating-user-interaction-animations","metadata":{"permalink":"/blog/2023/1/10/creating-user-interaction-animations","source":"@site/blog/2023-1-10-creating-user-interaction-animations/index.mdx","title":"DEV101 \u26a1 Creating user interaction animations","description":"Quick guide showing how you can use FOSS tools to create useful animations that show how you itend for a user to interact with your product","date":"2023-01-10T00:00:00.000Z","formattedDate":"January 10, 2023","tags":[{"label":"dev101","permalink":"/blog/tags/dev-101"}],"readingTime":6.535,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"DEV101 \u26a1 Creating user interaction animations","authors":"stephen","tags":["dev101"],"keywords":["product design","kicad","freecad","inkscape","prototyping","animations","gif","FOSS","opensource","oshw"],"description":"Quick guide showing how you can use FOSS tools to create useful animations that show how you itend for a user to interact with your product"},"prevItem":{"title":"New OSHWA certifications received!","permalink":"/blog/2023/1/12/oshwa-certification"},"nextItem":{"title":"DEV101 \u26a1 Adding applications to the PATH env variable","permalink":"/blog/2023/1/7/adding-apps-to-path-var"}},"content":"Well written and easy to follow documentation is a big part of creating and shipping a good product. Not only in the sense of documenting your design and code but the user instructions and\\nusage as well. It can sometimes be difficult to instruct a user on how to interact with a product just through textual documentation and an image can go a long way in helping a user understand\\nwhat you intend for them to do. An even better option is a quick and easy to follow animation that clearly shows the steps a user should take, leaving no room for a user to misconstrue instructions.\\n\\nIn this guide I\'ll show you how to go about making a quick 5 frame ```.gif``` (seen below) that illustrates how to jump the [atmega32u4_breakout](/docs/atmega32u4_breakout) board into the USB DFU bootloader via a\\nsequence of button presses. You can of course follow these steps and create an animation for any other user interaction you want to document.\\n\\n![gif animation showing the sequence to press buttons on a PCB. Press and hold RST, Press and hold USR, Release RST, Releast USR](./hwb_seq.gif)\\n\x3c!--truncate--\x3e\\nWe will be using a few different pieces of software to create our animation - All of which are fully open source and free to use:\\n- KiCAD\\n- FreeCAD\\n- Inkscape\\n- ImageMagick\\n\\n### KiCAD 3D PCB Export\\nTo get started we want a simple but accuracte depiction of the product that the user is intended to interact with. In our example the user interacts with push-buttons on an exposed PCB. To make\\nthings a bit less distracting and clean looking, we are going to take the ```.STEP``` output from KiCAD and import the model into FreeCAD allowing us to re-color all of the 3D bodies to a\\nsimple white.\\n\\nStart by opening your KiCAD PCB file in the PCB editor. Next go to ```File -> Export -> STEP```. Here we want to ensure ```Substitue similarly named models``` checkbox is selected before exporting.\\nOnce checked, press ```Export``` at the bottom.\\n\\n![KiCAD Export Step settings showing the Substitute similarly named models being checked](./3d_export_settings.png)\\n\\n### FreeCAD import & model recoloring\\nWith the 3D .STEP file exported we are ready to import it into the FOSS MCAD software, FreeCAD. Once imported we can recolor the 3d bodies to a white, giving us a clean and simple depiction of\\nthe PCB. With FreeCAD open, navigate to ```File -> New``` to open a blank document.\\n\\n![Image showing how to create a new file in FreeCAD](./freecad_new_file.png)\\n\\nNext we want to open the ```Parts``` workbench. To do so navigate to ```View -> Workbench -> Part```\\n\\n![Image showing how to open the Part workbench via the toolbar in FreeCAD](./freecad_view_workbench_part.png)\\n\\nWith the Part Workbench view selected we can now import our .STEP file we exported from KiCAD. Navigate to ```Part -> Import CAD``` and select your 3D .step file.\\n\\n![Image showing how to import a CAD file via the Part toolbar menu](./freecad_part_importcad.png)\\n\\nIn the project viewer on the left side of the screen you should see a long list of Solids with the name of your 3D step and a number after it - ```e.g - atmegaXu4_breakout001```. We want\\nto select the first item in the list - there should be no number after the solid name. Rick click and select the ```Set colors...``` option.\\n\\n![Image showing how to set the body color of an imported CAD file solid body](./freecad_setcolors.png)\\n\\nIn the ```Display properies``` pane that appears we want to keep the viewing mode as ```Flat Lines``` to give us a \\"simple\\" view of the PCB. Before editing the ```Shape color``` press\\n<kbd>SHIFT + B</kbd> to enable the group select tool. Drag and select the entire PCB model. Now when you update the ```Shape Color``` option, the entire PCB and components will update.\\n:::note\\nWhen setting the shape color to be white it will still appear to be Gray in isometric views. Select an orthographic view to see it as white (e.g. Top, Bottom, Left, Right)\\n:::\\n\\n![Image showing how to select all of the 3D solids at once to bulk edit the body color](./freecad_selectall.png)\\n\\nThe last thing to update before taking our picture is to set the background. The default background for FreeCAD is a color gradient and we want ours to be a solid white. To update the background\\ncolor go to ```Edit -> Preferences -> Display (on the left) -> Colors (tab)```. Here you can set the ```Background color``` to be a ```Simple color``` and use the color picker to set it to white.\\n\\n![Image showing how to change FreeCADs background from a gradient to a solid white color](./freecad_bg_color.png)\\n\\nOnce you\'ve set the background color, set the 3D view to the isometric or orthograpic view you want and take a picture. FreeCAD has a toolbar option to capture the current 3D viewing area by going\\nto ```Tools -> Save picture...```\\n\\n![Image showing how to export the current 3D viewing area as an image via the Tools toolbar menu](./freecad_savepicture.png)\\n\\nWith our picture of a simplified PCB we are ready to create our gif frames.\\n\\n### Creating frames in Inkscape\\nWe can now go about making the individual frames for our animation. To do so we are going to use the FOSS Vector Graphics software - Inkscape. To begin, we need to import our picture we just captured\\nfrom FreeCAD by pressing <kbd>CTRL + I</kbd> once Inkscape is open. Select your desired import properties and press ```OK```. We need an individual photo for each frame and the first frame will likely be a photo of the board\\nwith no instruction. To begin the export process and setting the final frame/animation size press <kbd>SHIFT + CTRL + E</kbd>. Here you can adjust your frame size to be standard, custom or fit to your\\nimage. Once you have the frame set as you\'d like, export the PNG to a folder which will hold all of our frames. Name the first frame ```1``` - as we create each frame, we will continue to save them with a number\\nfor a name, incrementing for each frame we create.\\n\\n![Image showing how to set the export image size and file name](./inkscape_export.png)\\n\\nThe next steps are going to be specific to your animation. In our example, we want to indicate a sequence of button presses. To do so we are going to import another image of a finger pointing\\nto the button to be pressed. In the example, we want the bottom button to be pressed and held - so we will first create a frame showing the button being pressed. Once we have the finger placed\\nwhere we\'d like we will export the image again and name the file ```2``` (Remember, each frame is named a number, incrementing by one from the previous frame number).\\n\\n![Image showing how to create subsequent frames by adding and new images overtop of the first frame](./inkscape_finger.png)\\n\\nRinse and repeat the step of adding fingers, lights, etc as needed - exporting each image with an ascending numerical file name until you have completed the capture of your frames. You should end\\nwith a folder full of ```.png``` images numbered ```1``` through ```n```.\\n\\n### Creating the final .gif animation\\nWe are finally ready for the easiest part of our process - combining our frames to create our user interaction animation!\\n\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n<Tabs groupId=\\"operating-systems\\">\\n  <TabItem value=\\"ubuntu\\" label=\\"Ubuntu\\" default>\\n\\n  On Ubuntu we can use the ImageMagick ```apt``` package to create out gif.\\n```console\\nsudo apt install imagemagick\\ncd DIR_HOLDING_FRAMES\\nconvert -delay 100 -loop 0 *.png user_animation.gif\\n```\\n\\n  </TabItem>\\n  <TabItem value=\\"website\\" label=\\"ezgif.com\\" default>\\n\\nGo to [ezgif.com](https://ezgif.com), upload your images and set the desired delay between each frame\\n\\n  </TabItem>\\n</Tabs>\\n\\nThat\'s it! You should now have a nice .gif to share or include with your documentation, clearly showing how to interact with the product."},{"id":"/2023/1/7/adding-apps-to-path-var","metadata":{"permalink":"/blog/2023/1/7/adding-apps-to-path-var","source":"@site/blog/2023-1-7-adding-apps-to-path-var.mdx","title":"DEV101 \u26a1 Adding applications to the PATH env variable","description":"Guide on how to add applications to the path environment variable so you can access them from the command line","date":"2023-01-07T00:00:00.000Z","formattedDate":"January 7, 2023","tags":[{"label":"dev101","permalink":"/blog/tags/dev-101"}],"readingTime":5.315,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"DEV101 \u26a1 Adding applications to the PATH env variable","authors":"stephen","tags":["dev101"],"keywords":["dev101","guides","PATH","environment variables","how to","linux","windows","powershell"],"description":"Guide on how to add applications to the path environment variable so you can access them from the command line"},"prevItem":{"title":"DEV101 \u26a1 Creating user interaction animations","permalink":"/blog/2023/1/10/creating-user-interaction-animations"},"nextItem":{"title":"New releases \ud83c\udf89 (kicad & avr templates, breakout boards)","permalink":"/blog/2022/12/28/new-releases"}},"content":"It often occurs in a developers day that they need to install a new application and be able to access it from the command line. In most cases a nicely packaged\\ninstaller (```.msi```, ```.exe``` or ```.AppImage```) is there to handle this process for you along with setting up directories and default config, all with a few clicks through a GUI.\\nSame goes for installing packages via a package manger like ```apt``` for Ubuntu or ```choco``` for Windows. A single command and the process is done.\\n\\nAlthough this is incredibly convenient, not all applications ship with an installer.\x3c!--truncate--\x3e You may encounter application directories that have been \\"zipped\\" or \\"tar-balled\\" and once\\nextracted gives you access to the application and dependencies when executed from its current home. When you receive a compressed folder like this it might just be\\nthe needed app inside or there may be a folder within called ```bin``` which contains your app. The easiest way to make the app accessible from the CLI is to add\\nthe folder path containing it to the ```PATH``` environment variable. By adding the app directory to the ```PATH``` env. variable, we build a list of directories that are searched any time an\\napp is called from the command line. The few steps below will walk you through doing this in both Linux and Windows.\\n\\n:::note\\nAs an example, we are going to install the [dfu-programmer](https://github.com/dfu-programmer/dfu-programmer/releases/tag/v1.0.0) CLI which allows a user to reflash\\nAtmel AVR microcontrollers via the USB-DFU class. The contents or use of the application is not important here but rather the process. If you\'d like to follow along installing\\na different application, feel free to do so.\\n:::\\n\\nimport Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n<Tabs groupId=\\"operating-systems\\">\\n  <TabItem value=\\"ubuntu\\" label=\\"Ubuntu\\" default>\\n\\nTo begin, place the uncompressed app folder wherever you\'d like on the filesystem. Typically when installing applications in this manner,\\nyou would place the application in the ```/usr/local``` folder.\\n```console\\nsudo mv dfu-programmer/ /usr/local/dfu-programmer\\n```\\n\\nIf we ```ls``` the app directory, we find the ```dfu-progammer``` executable. You may have another layer with a ```bin``` folder within that then contains your executable you want to\\nexecute. Regardless of where the application actually lives we want to add the full path to its storage location, to our PATH env variable. To do so, edit the ```.bashrc``` file located in your home directory.\\n```bash\\nvi ~/.bashrc\\n````\\n\\nWith the ```.bashrc``` file open - Add the following line anywhere in the file.\\n```bash\\nexport PATH=/usr/local/dfu-programmer:$PATH\\n```\\n:::caution\\nWhen adding the export statements you should use the path to the folder that contains the executable and should not include the executable name.\\n:::\\nThe above line pre-pends the path to our dfu-programmer directory to the current ```$PATH``` env variable and then assigns that new list back to itself (```PATH```). This rc file we just edited is\\nloaded every time a terminal is opened and the line we added will let our current shell know about the ```dfu-programmer``` location. To re-iterate, this line adds to the enviroment variable\\nand does not overwrite it. This means if we have multiple applications to install in this manner, we can have multiple export statements one after another that will not overwrite one another.\\n\\nTo test if our changes worked, source the rc file - making our current shell aware of the new directory we\'ve added to the ```PATH``` environment variable.\\n```console\\nsource ~/.bashrc\\n````\\n\\nNow try and execute our application from any directory on the file system.\\n```console\\ncd ~\\ndfu-programmer --version\\n```\\n\\nIf we were succesfull then we should see a version string of 1.0.0 printed on the console.\\n```console\\ndfu-programmer 1.0.0\\n````\\n:::note\\nIf the above did not work and you see something like ```Command X not found, did you mean:```, verify that the full path to the folder containing your executable was properly added to the\\n```.bashrc``` file. To guarantee the new rc file is being sourced you can close your terminal, open a new one and try the command again.\\n:::\\n\\n  </TabItem>\\n  <TabItem value=\\"windows\\" label=\\"Windows\\">\\n\\n:::note\\nAll of the commands in this guide are executed from a Powershell terminal.\\n:::\\n\\nTo begin, place the uncompressed app folder wherever you\'d like on the filesystem. Typically when installing applications in this manner, I like to place the app folder in my root ```C:\\\\```\\ndirectory.\\n```console\\nmv dfu-programmer-x64-1.0.0 C:\\\\\\n```\\n\\nIf we ```ls``` the app directory, we find the ```dfu-progammer.exe``` executable inside. You may have another layer with a ```bin``` folder within that then contains your executable you want to\\nexecute. Regardless of where the application actually lives we want to add the full path to its storage location, to our PATH env variable. To do so, execute the following from Powershell.\\n```Powershell\\n# Add to the current users path\\nsetx PATH \\"%PATH%;C:\\\\dfu-programmer-x64-1.0.0\\"\\n\\n# Add to all users path. Will require the PS to be ran as Administrator\\n# Start a new powershell as administrator\\nStart-process powershell -verb runas\\nsetx /M PATH \\"%PATH%;C:\\\\dfu-programmer-x64-1.0.0\\"\\n````\\n:::caution\\nWhen adding to the ```PATH``` env variable you should use the path to the folder that contains the executable and should not include the executable name.\\n:::\\nThe above line appends the path to our dfu-programmer directory to the ```%PATH%``` env variable and then assigns that new list back to itself (```PATH```). To re-iterate, this command adds to\\nthe enviroment variable and does not overwrite it.\\n\\nIn order for the ```PATH``` changes to take effect we need to close our current terminal and open a new one. Once the new terminal is open try and execute our application from any\\ndirectory on the file system.\\n```console\\ncd ~\\ndfu-programmer --version\\n```\\n\\nIf we were succesfull then we should see a version string of 1.0.0 printed on the console.\\n```console\\ndfu-programmer 1.0.0\\n````\\n:::note\\nIf the above did not work and you see something like ```X : The term \'X\' is not recognized as the name of a cmdlet, function, script file, or operable\\nprogram.```, verify that the full path to the folder containing your executable was properly added. You can verify what was added by typing ```$env:Path``` into Powershell. Your app directory\\nshould be one of the last in the list of directories printed.\\n:::\\n\\n  </TabItem>\\n</Tabs>\\n\\nThat\'s it! You now have access to your application via the command line and are ready to integrate the new app into your automation or general workflows."},{"id":"/2022/12/28/new-releases","metadata":{"permalink":"/blog/2022/12/28/new-releases","source":"@site/blog/2022-12-28-new-releases.md","title":"New releases \ud83c\udf89 (kicad & avr templates, breakout boards)","description":"New product release announcement for the breadboard-io, atmega32u4_breakout, kicad project template and the avr-cmake project template","date":"2022-12-28T00:00:00.000Z","formattedDate":"December 28, 2022","tags":[{"label":"new-release","permalink":"/blog/tags/new-release"}],"readingTime":2.395,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"New releases \ud83c\udf89 (kicad & avr templates, breakout boards)","authors":"stephen","tags":["new-release"],"keywords":["new release","templates","kicad","avr","atmel","microchip","breadboard","prototyping"],"description":"New product release announcement for the breadboard-io, atmega32u4_breakout, kicad project template and the avr-cmake project template"},"prevItem":{"title":"DEV101 \u26a1 Adding applications to the PATH env variable","permalink":"/blog/2023/1/7/adding-apps-to-path-var"},"nextItem":{"title":"Introduction \ud83d\udc4b","permalink":"/blog/2022/12/22/introduction"}},"content":"I\'m happy to finally be sharing several new projects with others! The templates will always be \\"under development\\" as I continue to add new suggestions and tweaks that make them more useful but the PCBs are pretty much \\"produciton\\" intent as most of the bugs have already been worked out.\x3c!--truncate--\x3e\\n- **breadboard-io [[docs]](https://os.everydaydev.io/docs/breadboard-io)[[github]](https://github.com/everyday-dev/breadboard-io)**: \ud83c\udf5e A small footprint design used to easily add a few push-buttons and LEDs to a breadboard\\n- **atmega32u4_breakout [[docs]](https://os.everydaydev.io/docs/atmega32u4-breakout/introduction)[[github]](https://github.com/everyday-dev/atmega32u4_breakout)**: Breakout and Development board for the ATmega32u4-MU MCU from Atmel. Even though its an 8-bit AVR part, its still plenty useful for most projects and most importantly - the MCU is avilable to purchase \ud83e\udee0\\n- **kicad-2-layer-template [[github]](https://github.com/everyday-dev/kicad-2-layer-template)**: \u267c 2-layer KiCAD project template with DRC rules set to meet PCBWays \\"Standard\\" tiers max capabilities\\n- **avr-cmake-template [[docs]](https://os.everydaydev.io/docs/Firmware/avr-cmake-template)[[github]](https://github.com/everyday-dev/avr-cmake-template)**: Template project for building AVR based firmware using VScode, CMake and the AVR toolchain\\n\\nFor the breakout boards and future hardware releases, the intent will be to not only post them publicly but also try and offer completely assembled PCBs for minimal cost to others so they can skip the building part if they want. The store will hopefully be coming soon but more priority is being placed on getting new content and projects added to the org. A couple new project should be coming soon (sneak peak below) and I will be making another post to announce those once they are finalized and released.\\n- **robin-sbc**:  An affordable and compact SBC offering a handful of useful serial interfaces (TWI, SPI, UART, CAN), 2x USB High Speed Host ports, 24bit LCD interface w/ I2C touch connector, NFC, and Wifi & Bluetooth connectivity.\\n- **can-hub**: A versatile 2-channel CAN hub device w/ digitally enabled termination and an SD for logging. The plan is to develop two subset of firmware:\\n    - SLCAN support giving you the ability to Read/Write/Listen on the bus using a standard interface via Python, C, or GUI apps\\n    - Custom firmware that offers the same feature set as the SLCAN but adds the ability to create config on the device that bridges data between the two CAN ports based on a set of filters. I also intend to add other features such as data logging to an SD card, replay functionality and message injection based on incoming packets.\\n- **10pin JTAG/SWD conn. breakout**: Easily breakout the 1.27mm pitch 10pin headers commonly used for JTAG/SWD onto a breadboard. The 2.54mm header is also compatible with the header on ST-Link JTAG Programmers which ship with STM32 Nucleo dev-boards - allowing a developer to add a 10pin header to their programmers making them a bit more useful for ST based projects.\\n\\nI hope to be getting a few more write-ups done in the near future walking through some topics such as CI/CD on hardware based projects, remote runners for Linux/Yocto projects and other general engineering design tips.\\n\\n\u26a1 Happy tinkering!"},{"id":"/2022/12/22/introduction","metadata":{"permalink":"/blog/2022/12/22/introduction","source":"@site/blog/2022-12-22-introduction.md","title":"Introduction \ud83d\udc4b","description":"Introducing the everyday\u26a1dev org to the world!","date":"2022-12-22T00:00:00.000Z","formattedDate":"December 22, 2022","tags":[{"label":"introduction","permalink":"/blog/tags/introduction"}],"readingTime":0.805,"hasTruncateMarker":true,"authors":[{"name":"Stephen Murphy","title":"Founder","url":"https://github.com/stephendpmurphy","imageURL":"/img/profile.jpeg","key":"stephen"}],"frontMatter":{"title":"Introduction \ud83d\udc4b","authors":"stephen","tags":["introduction"],"draft":false,"keywords":["introduction","everydaydev"],"description":"Introducing the everyday\u26a1dev org to the world!"},"prevItem":{"title":"New releases \ud83c\udf89 (kicad & avr templates, breakout boards)","permalink":"/blog/2022/12/28/new-releases"}},"content":"Hi there \ud83d\udc4b my name is Stephen and I\'m the creator and maintainer of everyday\u26a1dev - A collection of projects and products all containing FOSS and OSHW. The goal is to provide cool and useful tools, gadgets and software to you for free to build on your own.\x3c!--truncate--\x3e We also want to provide pre-built hardware for sale at a low cost on an online store, that way you can skip the build and get straight to tinkering if you\'d like. This site at the time of writing exists to hold the blog posts I write and the [documentation](/docs) for great lakes dev projects and products and you can expect a couple different things from this blog:\\n- General everyday\u26a1dev updates\\n- Showcases of projects/products\\n- Walk-through/guides on various Embedded Engineering problems/subjects\\n- Multi-part build updates and potential tear-downs/exploration of existing products\\n\\nIf you\'d like to reach out to suggest topics, projects or just to chat, considering connecting with me on [Mastodon](https://fosstodon.org/@stephendpmurphy)!"}]}')}}]);