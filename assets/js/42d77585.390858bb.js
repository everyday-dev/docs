"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5414],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,m=c["".concat(s,".").concat(h)]||c[h]||u[h]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},420:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={title:"AVR USB Made Simple - Vendor Specific Control Transfers",authors:"stephen",tags:["avr","usb","c","embedded","usb-made-simple"],draft:!1,keywords:["everydaydev","usb","avr","usb-made-simple"],description:"A multi-part introduction to USB on AVR microcontrollers. In Part 2 we cover the implementation of Vendor specific control transfers.",image:"img/everydaydev_black_on_white_linkedin_520x272.png"},r=void 0,l={permalink:"/blog/2023/9/21/avr-usb-made-simple-p2",source:"@site/blog/2023-9-21-avr-usb-made-simple-p2.mdx",title:"AVR USB Made Simple - Vendor Specific Control Transfers",description:"A multi-part introduction to USB on AVR microcontrollers. In Part 2 we cover the implementation of Vendor specific control transfers.",date:"2023-09-21T00:00:00.000Z",formattedDate:"September 21, 2023",tags:[{label:"avr",permalink:"/blog/tags/avr"},{label:"usb",permalink:"/blog/tags/usb"},{label:"c",permalink:"/blog/tags/c"},{label:"embedded",permalink:"/blog/tags/embedded"},{label:"usb-made-simple",permalink:"/blog/tags/usb-made-simple"}],readingTime:9.83,hasTruncateMarker:!0,authors:[{name:"Stephen Murphy",title:"Founder",url:"https://github.com/stephendpmurphy",imageURL:"/img/profile.jpeg",key:"stephen"}],frontMatter:{title:"AVR USB Made Simple - Vendor Specific Control Transfers",authors:"stephen",tags:["avr","usb","c","embedded","usb-made-simple"],draft:!1,keywords:["everydaydev","usb","avr","usb-made-simple"],description:"A multi-part introduction to USB on AVR microcontrollers. In Part 2 we cover the implementation of Vendor specific control transfers.",image:"img/everydaydev_black_on_white_linkedin_520x272.png"},nextItem:{title:"AVR USB Made Simple - Enumeration",permalink:"/blog/2023/9/16/avr-usb-made-simple-p1"}},s={authorsImageUrls:[void 0]},d=[{value:"Vendor Specific Control Transfers",id:"vendor-specific-control-transfers",level:2},{value:"Integrating into our main application",id:"integrating-into-our-main-application",level:2},{value:"Creating the hooks",id:"creating-the-hooks",level:3},{value:"Using the callbacks",id:"using-the-callbacks",level:3},{value:"Testing it out",id:"testing-it-out",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:d},c="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In our ",(0,i.kt)("a",{parentName:"p",href:"/blog/2023/9/16/avr-usb-made-simple-p1"},"previous post")," we implemented the bare minimum required to get a USB device to enumerate with the host and laid the groundwork\nfor adding actual communications to our device. In this post we will do just that by adding support Vendor Specific control transfers, allowing a Host to Write and Read data from\nthe device."),(0,i.kt)("p",null,"As a reminder from the previous post, we are using the ",(0,i.kt)("a",{parentName:"p",href:"/docs/atmega32u4_breakout/introduction"},"atmega32u4 breakout board"),", a breadboard friendly device with a USB 1.1 (Full-speed) interface.\nThe code to follow along can be found on our ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw"},"Github"),", just be sure to checkout the ",(0,i.kt)("inlineCode",{parentName:"p"},"control_vendor_rw"),"\ntag."),(0,i.kt)("p",null,"Without further ado, let's get started!"),(0,i.kt)("h2",{id:"vendor-specific-control-transfers"},"Vendor Specific Control Transfers"),(0,i.kt)("p",null,"Vendor specific control transfers are exactly as they sound. They are Control transfers, sent via a Setup packet, that are specific to the vendor of the device. They are a great way to implement\ndevice configuration, high level device control (on/off), status retrieval, and other low bandwidth items that don't require the overhead of a Bulk or Interrupt transfer."),(0,i.kt)("p",null,"To achieve this the host sends a setup packet with a ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequestType")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x40")," which indicates a vendor specific request. To clarify a bit, the ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequestType")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x40")," not only indicates a\nControl transfer but also that it is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"OUT")," direction, meaning Host to Device. The ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequestType")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0xC0")," indicates a Control transfer as well but in the ",(0,i.kt)("inlineCode",{parentName:"p"},"IN")," direction, meaning Device\nto Host. When implementing Vendor specific control transfers in our device firmware we don't actually care about the ",(0,i.kt)("inlineCode",{parentName:"p"},"IN")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"OUT")," direction as we will be handling both in the same way. The ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequestType")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x40"),"\nis all we need to know and then we will be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequest")," value to determine if the transfer is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Write")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Read"),". Let's see some code!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"else if((bmRequestType & 0x60) == 0x40) { // Vendor specific request type\n    switch(bRequest) {\n        case 0x01:\n\n            // A packet was WRITTEN to us. Do something with the\n            // wValue and wIndex values here if needed.\n            // myVariable = wValue\n\n            // Reply with a ZLP\n            UEINTX &= ~(1 << TXINI);\n            // Wait for the bank to become ready again\n            while (!(UEINTX & (1<<TXINI)));\n            break;\n\n        case 0x02:\n            // Some data was requested from us. We can see how much data\n            // was requested from us using the wLength value. Load up\n            // the requested data and send it back as the `DATA` phase\n            for(uint16_t i = 0; i < wLength; i++) {\n                UEDATX = i;\n            }\n\n            // Clear the TXINI bit to initiate the transfer\n            UEINTX &= ~(1 << TXINI);\n            // Wait for the bank to become ready again\n            while (!(UEINTX & (1<<TXINI)));\n            break;\n\n        default:\n            // Unsupported vendor specific request. Reply with a STALL\n            UECONX |= (1 << STALLRQ);\n            break;\n    }\n}\n")),(0,i.kt)("p",null,"As you can see we add a new ",(0,i.kt)("inlineCode",{parentName:"p"},"else if")," block to our ",(0,i.kt)("inlineCode",{parentName:"p"},"_processSetupPacket")," function to check if the Vendor specific transfer type is set. From there we say that a ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequest")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x01")," indicates the\nhost is writing data to us (",(0,i.kt)("inlineCode",{parentName:"p"},"OUT"),"), and a ",(0,i.kt)("inlineCode",{parentName:"p"},"bRequest")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x02")," indicates the host is requesting data from us (",(0,i.kt)("inlineCode",{parentName:"p"},"IN"),"). Again to clarify, you could also implement two separate ",(0,i.kt)("inlineCode",{parentName:"p"},"else if")," blocks for ",(0,i.kt)("inlineCode",{parentName:"p"},"0x40"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"0xC0")," to further separate out the ",(0,i.kt)("inlineCode",{parentName:"p"},"IN")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"OUT")," directions but for our purposes we are just going to handle them the same way."),(0,i.kt)("p",null,"The handling itself is pretty straight forward: for a ",(0,i.kt)("inlineCode",{parentName:"p"},"Write")," we store\nthe provided ",(0,i.kt)("inlineCode",{parentName:"p"},"wValue")," and then reply with a ZLP (Zero length packet) to acknowledge the write. A read is just as simple, we check the requested length set via the ",(0,i.kt)("inlineCode",{parentName:"p"},"wLength")," parameter and then load up the\ndata to send back to the host. Once the data is loaded we initiate the transfer. If the host requests more data than we have available we will just send back whatever we have.\nCare should also be taken that all responses back to the Host fit within the defined packet size for your endpoint. Meaning you might need to break up your response into multiple packets if the requested\n",(0,i.kt)("inlineCode",{parentName:"p"},"wLength")," is greater than the packet size."),(0,i.kt)("h2",{id:"integrating-into-our-main-application"},"Integrating into our main application"),(0,i.kt)("p",null,"Now that we can read and write data to our device, how do we actually use it in our application? The first and simplest way is to just add your get/set functions directly into the new ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement for\nhandling control transfers. This is fine for simple applications but we can do better. Let's add some hooks into our main application that will allow us to register functions to be called when a transfer is\nreceived."),(0,i.kt)("h3",{id:"creating-the-hooks"},"Creating the hooks"),(0,i.kt)("p",null,"To start we will add two new function types to our ",(0,i.kt)("inlineCode",{parentName:"p"},"usb.h")," file. The first function type ",(0,i.kt)("inlineCode",{parentName:"p"},"usb_controlWrite_rx_cb_t")," is a function that takes a single ",(0,i.kt)("inlineCode",{parentName:"p"},"uint16_t")," parameter and returns nothing - this will be used for our ",(0,i.kt)("inlineCode",{parentName:"p"},"Write")," callback, meaning it's called when the host\nwrites data to us, and the value written is passed as the ",(0,i.kt)("inlineCode",{parentName:"p"},"rxData")," variable. The second function type ",(0,i.kt)("inlineCode",{parentName:"p"},"usb_controlRead_tx_cb_t")," is a function that takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"uint8_t")," pointer and a ",(0,i.kt)("inlineCode",{parentName:"p"},"uint16_t")," parameter and returns\na ",(0,i.kt)("inlineCode",{parentName:"p"},"uint16_t")," - this will be used for our ",(0,i.kt)("inlineCode",{parentName:"p"},"Read")," callback, meaning it's called when the host requests data from us, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"txData")," pointer is where we will write our data to send back to the host, the ",(0,i.kt)("inlineCode",{parentName:"p"},"requestedTxLen"),"\nis the amount of data requested by the host. The return value of the function is the amount of data actually written to the ",(0,i.kt)("inlineCode",{parentName:"p"},"txData")," buffer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"typedef void (*usb_controlWrite_rx_cb_t)(uint16_t rxData);\ntypedef uint16_t (*usb_controlRead_tx_cb_t)(uint8_t *txData, const uint16_t requestedTxLen);\n\n")),(0,i.kt)("p",null,"Now we have a set of callbacks that we can register with our USB library. First create two new variables in our ",(0,i.kt)("inlineCode",{parentName:"p"},"usb.c")," file to store the callbacks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"usb_controlWrite_rx_cb_t _setupWrite_cb = NULL;\nusb_controlRead_tx_cb_t _setupRead_cb = NULL;\n")),(0,i.kt)("p",null,"Let's update our ",(0,i.kt)("inlineCode",{parentName:"p"},"usb_init")," function to take these callbacks as parameters and store them in our new variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void usb_init(usb_controlWrite_rx_cb_t onControlWriteCb, usb_controlRead_tx_cb_t onControlReadCb) {\n    // Power-On USB pads regulator\n    UHWCON |= (1 << UVREGE);\n\n    // VBUS int enable, VBUS pad enable, USB Controller enable\n    USBCON |= (1 << USBE) | (1 << OTGPADE) | (1 << FRZCLK);\n\n    // Toggle the FRZCLK to get WAKEUP IRQ\n    USBCON &= ~(1 << FRZCLK);\n    USBCON |= (1 << FRZCLK);\n\n    // Set the PLL input divisor to be 1:2 since we have\n    // at 16MHz input (we want 8MHz output on the PLL)\n    PLLCSR |= (1 << PINDIV);\n\n    // Default USB postscaler is fine as it generates\n    // the 48Mhz clock from the 8Mhz PLL input by default\n\n    // Start the PLL\n    PLLCSR |= (1 << PLLE);\n\n    // Wait for the PLL to lock\n    while (!(PLLCSR &(1<<PLOCK)));\n\n    // Leave power saving mode\n    USBCON &= ~(1 << FRZCLK);\n\n    // Store our CB if we received one\n    if(onControlWriteCb != NULL) {\n        _setupWrite_cb = onControlWriteCb;\n    }\n\n    if(onControlReadCb != NULL) {\n        _setupRead_cb = onControlReadCb;\n    }\n\n    // Attach the device by clearing the detach bit\n    // This is acceptable in the case of a bus-powered device\n    // otherwise you would initiate this step based on a\n    // VBUS detection.\n    UDCON &= ~(1 << DETACH);\n\n    // Enable the USB Reset IRQ. This IRQ fires when the\n    // host sends a USB reset to the device to kickoff\n    // USB enumeration. Init of the USB will continue in the\n    // ISRs when the reset signal is received.\n    UDIEN |= (1 << EORSTE);\n}\n")),(0,i.kt)("p",null,"Next, we need to add our callback definitions in ",(0,i.kt)("inlineCode",{parentName:"p"},"main.c")," and pass them as parameters to our ",(0,i.kt)("inlineCode",{parentName:"p"},"usb_init")," call."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"\nvoid onUsbControlWrite(uint16_t rxData) {\n    // Do something with the rxData that was just written to us from the Host\n}\n\nuint16_t onUsbControlRead(uint8_t *txData, const uint16_t requestedTxLen) {\n    uint16_t txLen = 0;\n\n    // Load up data into the txData buffer to send back to the host.\n    // Make sure to also update txLen with the amount of data that we load\n\n    return txLen;\n}\n\nint main(void) {\n    // Set our LED port as an output\n    LED_STAT_DDR |= (1 << LED_STAT_PIN);\n\n    // Init USB and provide it our callback function\n    // to be called when data is received via a\n    // Control Write transfer\n    usb_init(onUsbControlWrite, onUsbControlRead);\n\n    // Enable global interrupts\n    sei();\n\n    while(1) {\n        // Do nothing\n    }\n}\n")),(0,i.kt)("p",null,"Last, we need to call the callbacks from our ",(0,i.kt)("inlineCode",{parentName:"p"},"usb.c")," file when a control transfer is received. Let's update our ",(0,i.kt)("inlineCode",{parentName:"p"},"else if")," block for handling control transfers to look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"else if((bmRequestType & 0x60) == 0x40) { // Vendor specific request type\n    switch(bRequest) {\n        case 0x01:\n            // If we have a callback stored, call it with the value\n            if(_setupWrite_cb != NULL) {\n                _setupWrite_cb(wValue);\n            }\n\n            // Reply with a ZLP\n            UEINTX &= ~(1 << TXINI);\n            // Wait for the bank to become ready again\n            while (!(UEINTX & (1<<TXINI)));\n            break;\n\n        case 0x02:\n            if(_setupRead_cb != NULL) {\n                // Call our callback to get the data to send back\n                uint16_t txLen = _setupRead_cb(_setup_read_buff,\n                    (wLength > CONTROL_EP_BANK_SIZE ?\n                        CONTROL_EP_BANK_SIZE :\n                        wLength));\n                // Send the data back to the host\n                for(uint16_t i = 0; i < txLen; i++) {\n                    UEDATX = _setup_read_buff[i];\n                }\n                // Clear the TXINI bit to initiate the transfer\n                UEINTX &= ~(1 << TXINI);\n                // Wait for the bank to become ready again\n                while (!(UEINTX & (1<<TXINI)));\n            }\n            else {\n                // No callback was provided so\n                // reply with a stall\n                UECONX |= (1 << STALLRQ);\n            }\n            break;\n\n        default:\n            // Unsupported vendor specific request. Reply with a STALL\n            UECONX |= (1 << STALLRQ);\n            break;\n    }\n}\n")),(0,i.kt)("p",null,"Now when a control transfer is received we will call the appropriate callback if one was provided. Next let's fill out the callbacks in our application to actually do something with the\ndata that is received or requested."),(0,i.kt)("h3",{id:"using-the-callbacks"},"Using the callbacks"),(0,i.kt)("p",null,"For the ",(0,i.kt)("inlineCode",{parentName:"p"},"Write")," callback, we are going to store the received data and then handle it in the main loop. We don't want to do much more than that since these callbacks are actually being\ncalled from the ISR in ",(0,i.kt)("inlineCode",{parentName:"p"},"usb.c"),". We should be as quick and efficient as possible, offloading any heavy lifting to the main loop. In our example we are going to be using the received value\nas an LED state, which we will update in the main loop. In the ",(0,i.kt)("inlineCode",{parentName:"p"},"Read")," callback we are going to load up a single value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x03")," into the buffer and return with a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0x01")," since we\nloaded a single byte. Let's see the code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"uint16_t my_led_state = 0;\n\nvoid onUsbControlWrite(uint16_t rxData) {\n    my_led_state = rxData;\n}\n\nuint16_t onUsbControlRead(uint8_t *txData, const uint16_t requestedTxLen) {\n    uint16_t txLen = 1;\n\n    txData[0] = 0x03;\n\n    return txLen;\n}\n\nint main(void) {\n    // Set our LED port as an output\n    LED_STAT_DDR |= (1 << LED_STAT_PIN);\n\n    // Init USB and provide it our callback function\n    // to be called when data is received via a\n    // Control Write transfer\n    usb_init(onUsbControlWrite, onUsbControlRead);\n\n    // Enable global interrupts\n    sei();\n\n    while(1) {\n        if(my_led_state) {\n            LED_STAT_PORT |= (1 << LED_STAT_PIN);\n        }\n        else {\n            LED_STAT_PORT &= ~(1 << LED_STAT_PIN);\n        }\n    }\n}\n")),(0,i.kt)("p",null,"That's it, we're ready to connect with a Host and send vendor specific data!"),(0,i.kt)("h2",{id:"testing-it-out"},"Testing it out"),(0,i.kt)("p",null,"To test out our new Vendor specific control transfers we have three languages to pick from: C, Python, and NodeJS. Each of these languages have an example for both the ",(0,i.kt)("inlineCode",{parentName:"p"},"Write")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Read")," transfers."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw/host/c"},"C example")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw/host/nodejs"},"NodeJS example")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/everyday-dev/avr-usb-made-simple/tree/control_vendor_rw/host/python"},"Python example"))),(0,i.kt)("p",null,"At each link you'll find instructions for building and using the applications."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"That's it, we now have a working USB device that can be controlled via Vendor specific control transfers! In coming posts we will cover the Interrupt, Bulk and Isochronous transfer types, where we will\ntalk about their key differences and when to use each one. We will also cover how to implement them in our device firmware. Stay tuned!"))}u.isMDXComponent=!0}}]);