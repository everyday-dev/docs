"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8889],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=r,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||a;return n?i.createElement(m,o(o({ref:t},d),{},{components:n})):i.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},792:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=n(7462),r=(n(7294),n(3905));const a={title:"AVR USB Made Simple - Enumeration",authors:"stephen",tags:["avr","usb","c","embedded","usb-made-simple"],draft:!1,keywords:["everydaydev","usb","avr","usb-made-simple"],description:"A multi-part introduction to USB on AVR microcontrollers. Part 1 covers the basics of USB and how to get a device enumerating in an OS.",image:"img/everydaydev_black_on_white_linkedin_520x272.png"},o=void 0,s={permalink:"/blog/2023/9/16/avr-usb-made-simple-p1",source:"@site/blog/2023-9-16-avr-usb-made-simple-p1.mdx",title:"AVR USB Made Simple - Enumeration",description:"A multi-part introduction to USB on AVR microcontrollers. Part 1 covers the basics of USB and how to get a device enumerating in an OS.",date:"2023-09-16T00:00:00.000Z",formattedDate:"September 16, 2023",tags:[{label:"avr",permalink:"/blog/tags/avr"},{label:"usb",permalink:"/blog/tags/usb"},{label:"c",permalink:"/blog/tags/c"},{label:"embedded",permalink:"/blog/tags/embedded"},{label:"usb-made-simple",permalink:"/blog/tags/usb-made-simple"}],readingTime:14.765,hasTruncateMarker:!0,authors:[{name:"Stephen Murphy",title:"Founder",url:"https://github.com/stephendpmurphy",imageURL:"/img/profile.jpeg",key:"stephen"}],frontMatter:{title:"AVR USB Made Simple - Enumeration",authors:"stephen",tags:["avr","usb","c","embedded","usb-made-simple"],draft:!1,keywords:["everydaydev","usb","avr","usb-made-simple"],description:"A multi-part introduction to USB on AVR microcontrollers. Part 1 covers the basics of USB and how to get a device enumerating in an OS.",image:"img/everydaydev_black_on_white_linkedin_520x272.png"},prevItem:{title:"AVR USB Made Simple - Vendor Specific Control Transfers",permalink:"/blog/2023/9/21/avr-usb-made-simple-p2"},nextItem:{title:"We're back - and we have a new name",permalink:"/blog/2023/6/30/rebranding"}},c={authorsImageUrls:[void 0]},l=[{value:"USB basics",id:"usb-basics",level:2},{value:"USB Enumeration",id:"usb-enumeration",level:2},{value:"AVR USB",id:"avr-usb",level:2},{value:"USB Init",id:"usb-init",level:3},{value:"USB Interrupts",id:"usb-interrupts",level:3},{value:"Endpoint Initialization",id:"endpoint-initialization",level:3},{value:"Setup Packet Handling",id:"setup-packet-handling",level:3},{value:"Descriptors",id:"descriptors",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:l},u="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this multi-part series, we will explore USB implementation on AVR microcontrollers, starting with the basics of USB enumeration. USB can be found all around us in our everyday\nlives. It's in our phones, our computers, our cars, and even our home appliances. It's a ubiquitous standard that has been around for decades and is still going strong. However\nwe often take it for granted as engineers and developers. Silicon vendors have made it so easy to get a device up and running with USB via their libraries and examples\nthat we don't often think about what's going on under the hood."),(0,r.kt)("p",null,"This series of posts is going attempt to demystify USB and show how to implement it in a bare-metal environment. For these posts I'll be using the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/atmega32u4_breakout/introduction"},"atmega32u4 breakout board")," which has a USB 1.1 (Fullspeed) interface and is breadboard friendly. The simple register\nbased setup of the AVR microcontrollers makes it a great platform to learn the basics of USB with as little abstraction as possible so not to many of the details\nare hidden from us. It's worth mentioning that there is a very popular library called ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/abcminiuser/lufa"},"LUFA")," that implements a USB stack for\nAVR microcontrollers. It's a great library and easy to use but it's also a bit of a black box."),(0,r.kt)("p",null,"You can ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/everyday-dev/avr-usb-made-simple/tree/control_basic_enum"},"find the code to follow along on our Github.")," Just be sure you are looking at the\n",(0,r.kt)("inlineCode",{parentName:"p"},"control_basic_enum")," tag. The repository is based on our ",(0,r.kt)("a",{parentName:"p",href:"docs/avr-cmake-template"},"avr-cmake-template")," and built using the ",(0,r.kt)("inlineCode",{parentName:"p"},"avr-gcc")," toolchain."),(0,r.kt)("h2",{id:"usb-basics"},"USB basics"),(0,r.kt)("p",null,"A great place to learn the basics of USB communication is this ",(0,r.kt)("a",{parentName:"p",href:"https://www.usbmadesimple.co.uk/index.html"},"USB Made Simple")," site. It starts out giving a\nhigh-level overview of the USB standard and then goes into the details of the protocol. I highly recommend reading through the site at least up to Part 4 to better\nunderstand the concepts I'll be talking about in this post."),(0,r.kt)("h2",{id:"usb-enumeration"},"USB Enumeration"),(0,r.kt)("p",null,"The bare minimum functionality of a USB device is to enumerate with the host which is the process of the host collecting information about the device and it's capabilities.\nThe host does so by initiating ",(0,r.kt)("inlineCode",{parentName:"p"},"Control")," transfers to the USB endpoint ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", querying information such as the devices product name, manufacturer, serial number and supported\ninterfaces. The host will then use this information to load the appropriate drivers to continue device\nspecific communication."),(0,r.kt)("h2",{id:"avr-usb"},"AVR USB"),(0,r.kt)("p",null,"Our objective in this post is not to implement any host driver functionality but to get our device to enumerate with the host. When we are all done the kernel log output on a\nLinux machine should look like this when the device is plugged in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"[986045.250483] usb 3-8.2: new full-speed USB device number 23 using xhci_hcd\n[986045.401173] usb 3-8.2: New USB device found, idVendor=dead, idProduct=beef, bcdDevice= 0.01\n[986045.401185] usb 3-8.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[986045.401189] usb 3-8.2: Product: avr usb made simple\n[986045.401192] usb 3-8.2: Manufacturer: everydaydev\n[986045.401195] usb 3-8.2: SerialNumber: 2023\n")),(0,r.kt)("h3",{id:"usb-init"},"USB Init"),(0,r.kt)("p",null,"Our first step is to create our USB init function. This will handle setting up the USB peripheral power rails, configuring the PLL for our clock source, and enabling\nany required interrupts. Note: In this example we are using the external 16MHz crystal on the atmega32u4 breakout board. If you are using a different board or a different clock\nconfiguration you will need to adjust the PLL. The main objective is to get a 48MHz clock source for the USB peripheral."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"void usb_init(void) {\n    // Power-On USB pads regulator\n    UHWCON |= (1 << UVREGE);\n\n    // VBUS int enable, VBUS pad enable, USB Controller enable\n    USBCON |= (1 << USBE) | (1 << OTGPADE) | (1 << FRZCLK);\n\n    // Toggle the FRZCLK to get WAKEUP IRQ\n    USBCON &= ~(1 << FRZCLK);\n    USBCON |= (1 << FRZCLK);\n\n    // Set the PLL input divisor to be 1:2 since we have\n    // at 16MHz input (we want 8MHz output on the PLL)\n    PLLCSR |= (1 << PINDIV);\n\n    // Default USB postscaler is fine as it generates\n    // the 48Mhz clock from the 8Mhz PLL input by default\n\n    // Start the PLL\n    PLLCSR |= (1 << PLLE);\n\n    // Wait for the PLL to lock\n    while (!(PLLCSR &(1<<PLOCK)));\n\n    // Leave power saving mode\n    USBCON &= ~(1 << FRZCLK);\n\n    // Attach the device by clearing the detach bit\n    // This is acceptable in the case of a bus-powered device\n    // otherwise you would initiate this step based on a\n    // VBUS detection.\n    UDCON &= ~(1 << DETACH);\n\n    // Enable the USB Reset IRQ. This IRQ fires when the\n    // host sends a USB reset to the device to kickoff\n    // USB enumeration. Init of the USB will continue in the\n    // ISRs when the reset signal is received.\n    UDIEN |= (1 << EORSTE);\n}\n")),(0,r.kt)("h3",{id:"usb-interrupts"},"USB Interrupts"),(0,r.kt)("p",null,"A crucial part of USB communication is the handling of interrupts as all communication will be initiated through them. The AVR USB peripheral has two categories of interrupts: The ",(0,r.kt)("inlineCode",{parentName:"p"},"GEN")," interrupt vector is where information such as bus resets and VBUS changes are\nhandled and the ",(0,r.kt)("inlineCode",{parentName:"p"},"COM")," interrupt vector is where all USB communication is handled. This includes ",(0,r.kt)("inlineCode",{parentName:"p"},"Control"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Bulk"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Interrupt"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Isochronous")," transfers.\nOur basic ISRs to achieve USB enumeration look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"ISR(USB_GEN_vect) {\n    // Check if a USB reset sequence was received from the host\n    if (UDINT & (1<<EORSTI)) {\n        // Clear the interrupt flag\n        UDINT &= ~(1<<EORSTI);\n        // Init our device endpoints\n        _endpoint_init();\n        // Enable our Setup RX interrupt. This causes\n        // an ISR to fire when a Setup packet is received\n        UEIENX |= (1<<RXSTPE);\n    }\n}\n\nISR(USB_COM_vect) {\n    // Check which endpoint caused the interrupt\n    switch (UEINT) {\n        case (1<<EPINT0):\n            // Select EP 0 before checking the interrupt register\n            UENUM = 0;\n            // Check if we received a Setup packet\n            if (UEINTX & (1<<RXSTPI)) {\n                // Handle the setup packet\n                _processSetupPacket();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n")),(0,r.kt)("p",null,"As you can see we are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"GEN")," vector to detect the ",(0,r.kt)("inlineCode",{parentName:"p"},"End Of Reset")," interrupt. This occurs when the host resets a device and is wanting\nthe device to begin the enumeration process. When this interrupt fires we then initialize our endpoints - We'll come back to that later. Inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"COM")," vector\nyou can see we determine which Endpoint caused a communications interrupt (Control transfers always use Endpoint 0) and then we act on what type of communication\ninterrupt was triggered. In our bare example we are only looking for ",(0,r.kt)("inlineCode",{parentName:"p"},"Setup")," packets. These are the packets that the host sends to the device to query information.\nWe will dive into our ",(0,r.kt)("inlineCode",{parentName:"p"},"Setup")," packet handler shortly."),(0,r.kt)("h3",{id:"endpoint-initialization"},"Endpoint Initialization"),(0,r.kt)("p",null,'Endpoints are "pipes" that data is sent and received in and must be initialized with a bank size indicating how much data can be written to/from the pipe during any transfer. In our bare enumeration example we will be implementing just the our Control endpoint (EP0) so we can handle Setup packets from the Host. We start by selecting EP0, resetting its FIFO and enabling it in the OUT direction. Once complete,\nwe enable the endpoint interrupt which allow us to detect when a Setup packet is received.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"bool _endpoint_init(void) {\n    // Select Endpoint 0\n    UENUM = 0x00;\n    // Reset the endpoint fifo\n    UERST = 0x7F;\n    UERST = 0x00;\n    // Enable the endpoint\n    UECONX |= (1 << EPEN);\n    // Configure endpoint as Control with OUT direction\n    UECFG0X = 0;\n    // Configure endpoint size\n    UECFG1X = (1 << EPSIZE1) | (1 << EPSIZE0);\n    // Allocate the endpoint buffers\n    UECFG1X |= (1 << ALLOC);\n    // Enable the endpoint interrupt\n    UEIENX |= (1 << RXSTPE) | (1 << RXOUTE);\n    // Check if endpoint configuration is ok\n    return((UESTA0X & (1 << CFGOK)));\n}\n")),(0,r.kt)("h3",{id:"setup-packet-handling"},"Setup Packet Handling"),(0,r.kt)("p",null,"The final piece (and most important) is the handling of the Setup packet. This is where the host will query information about the device, set the bus address, and set the\ndevice configuration. The received Setup packet is 8 bytes long and contains information such as the request type, request, value, index, and length. The first step is to read the 8 bytes\nfrom the FIFO and then acknowledge the packet by clearing the RXSTPI bit. We then check the request type to determine what type of request was sent. In our example we are only handling\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"Standard")," request type. From here you can see we handle ",(0,r.kt)("inlineCode",{parentName:"p"},"GET_STATUS"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SET_ADDRESS"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"GET_DESCRIPTOR"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"SET_CONFIGURATION")," requests from the Host allowing it to fully configure and enumerate the device in the OS."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'static void  _processSetupPacket(void) {\n    // Read the 8 bytes from the setup packet. Depending on the type of request\n    // each value may have a different use/meaning. Reference "The SETUP Packet" section\n    // of https://www.usbmadesimple.co.uk/ums_4.htm for more information on what each byte\n    // means for a given request type.\n    uint8_t bmRequestType = UEDATX;\n    uint8_t bRequest = UEDATX;\n    uint8_t wValue_l = UEDATX;\n    uint8_t wValue_h = UEDATX;\n    uint8_t wIndex_l = UEDATX;\n    uint8_t wIndex_h = UEDATX;\n    uint8_t wLength_l = UEDATX;\n    uint8_t wLength_h = UEDATX;\n    uint16_t descriptorLength = 0;\n\n    // Ack the received setup package by clearing the RXSTPI bit\n    UEINTX &= ~(1 << RXSTPI);\n\n    if ((bmRequestType & 0x60) == 0) { // Standard request type\n        switch (bRequest) {\n            case GET_STATUS:\n                // Reply with 16 bits for our status. We are self powered, no remote-wakeup\n                // and we are not halted.\n                UEDATX = 0;\n                UEDATX = 0;\n                // Clear the TXINI bit to initiate the transfer\n                UEINTX &= ~(1 << TXINI);\n                // Wait for ZLP from host\n                while (!(UEINTX & (1 << RXOUTI)));\n                // Clear the RXOUTI bit to acknowledge the packet\n                UEINTX &= ~(1 << RXOUTI);\n                break;\n\n            case SET_ADDRESS:\n                // Section 22.7 of https://ww1.microchip.com/downloads/en/devicedoc/atmel-7766-8-bit-avr-atmega16u4-32u4_datasheet.pdf\n                // Device stores received address in the UDADDR register.\n                UDADDR = (wValue_l & 0x7F);\n                // Device should then respond with a ZLP to acknowledge the request\n                UEINTX &= ~(1 << TXINI);\n                // Wait for the bank to become ready again (TIXINI set)\n                while (!(UEINTX & (1<<TXINI)));\n                // After sending the ZLP, the device should apply the address by setting the ADDEN bit\n                UDADDR |= (1 << ADDEN);\n                break;\n\n            case GET_DESCRIPTOR:\n                switch (wValue_h) {\n                    case DESC_DEVICE:\n                        // Retrieve the Device desc length from the descriptor\n                        // structure. This is the first byte of the descriptor.\n                        descriptorLength = pgm_read_byte(&DeviceDescriptor[0]);\n                        // Send it back to the host\n                        _sendDescriptor((uint8_t*) DeviceDescriptor, descriptorLength);\n                        break;\n\n                    case DESC_CONFIG:\n                        // The Host will first request the base Config descriptor which is of length\n                        // 9 to determine how many interfaces are available.\n                        // However, once the host determines how many interfaces are available it will then\n                        // do another Config descriptor read with the full length of the descriptor.\n                        descriptorLength = wLength_l + (wLength_h << 8);\n                        // Send the descriptor with the requested length\n                        _sendDescriptor((uint8_t*)ConfigDescriptor, descriptorLength);\n                        break;\n\n                    case DESC_STRING:\n                        switch (wValue_l) {\n                            case DESC_STRING_LANG:\n                                // Retrieve the Language desc length from the descriptor\n                                // structure. This is the first byte of the descriptor.\n                                descriptorLength = pgm_read_byte(&LanguageDescriptor[0]);\n                                // Send it back to the host\n                                _sendDescriptor((uint8_t*) LanguageDescriptor,descriptorLength);\n                                break;\n\n                            case DESC_STRING_MANUF:\n                                // Retrieve the Manufacturer string desc length from the descriptor\n                                // structure. This is the first byte of the descriptor.\n                                descriptorLength = pgm_read_byte(&ManufacturerStringDescriptor[0]);\n                                // Send it back to the host\n                                _sendDescriptor((uint8_t*) ManufacturerStringDescriptor,descriptorLength);\n                                break;\n\n                            case DESC_STRING_PROD:\n                                // Retrieve the Product string desc length from the descriptor\n                                // structure. This is the first byte of the descriptor.\n                                descriptorLength = pgm_read_byte(&ProductStringDescriptor[0]);\n                                // Send it back to the host\n                                _sendDescriptor((uint8_t*) ProductStringDescriptor,descriptorLength);\n                                break;\n\n                            case DESC_STRING_SERIAL:\n                                // Retrieve the Serial string desc length from the descriptor\n                                // structure. This is the first byte of the descriptor.\n                                descriptorLength = pgm_read_byte(&SerialStringDescriptor[0]);\n                                // Send it back to the host\n                                _sendDescriptor((uint8_t*) SerialStringDescriptor,descriptorLength);\n                                break;\n\n                            default:\n                                break;\n                        }\n                        break;\n\n                    default:\n                        break;\n                }\n                break;\n\n            case SET_CONFIGURATION:\n                // Select EP 0\n                UENUM = 0;\n                // Reply with a ZLP to acknowledge the request\n                UEINTX &= ~(1 << TXINI);\n                // Wait for the bank to be ready again\n                while (!(UEINTX & (1<<TXINI)));\n                break;\n\n            default:\n                // Invalid request was sent. Reply with a STALl\n                UECONX |= (1 << STALLRQ);\n                break;\n        }\n    }\n    else if((bmRequestType & 0x60) == 0x40) { // Vendor specific request type\n        switch(bRequest) {\n            default:\n                // Unsupported vendor specific request. Reply with a STALL\n                UECONX |= (1 << STALLRQ);\n                break;\n        }\n    }\n    else { // Invalid request type\n        // Reply with a STALL\n        UECONX |= (1 << STALLRQ);\n    }\n}\n')),(0,r.kt)("p",null,"The last piece is our function for sending descriptors back to the host. This is pretty straight forward but it should be noted that we take care to\nbreak up the descriptor into 8 byte chunks. This is because the host will only read 8 bytes at a time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'static void _sendDescriptor(const uint8_t* descriptor, uint16_t length) {\n    // See section 22.12.2 of https://ww1.microchip.com/downloads/en/devicedoc/atmel-7766-8-bit-avr-atmega16u4-32u4_datasheet.pdf\n    // for an illustration of the "Control Read" process. Specifically the "DATA" and "STATUS"\n    // portion of the timing diagram are handled here.\n\n    // We are going to chunk the descriptor into 8 byte packets. Looping until we have finished\n    for(uint16_t i = 1; i <= length; i++) {\n        if(UEINTX & (1 << RXOUTI)) {\n            // We received an OUT packet which means\n            // the HOST wants us to abort.\n            // Clear the RXOUTI bit to acknowledge the packet\n            UEINTX &= ~(1 << RXOUTI);\n            return;\n        }\n\n        // Load the next byte from our descriptor\n        UEDATX = pgm_read_byte(&descriptor[i-1]);\n        // If our packet is full\n        if(((i%8) == 0)) {\n            // Clear the TXINI bit to initiate the transfer\n            UEINTX &= ~(1 << TXINI);\n            // Wait for transmission to complete (TXINI set) or\n            // the HOST to abort (RXOUTI set)\n            while (!(UEINTX & ((1 << RXOUTI) | (1<<TXINI))));\n        }\n    }\n    // Go ahead and transmit the remaining data (if there is any) if the HOST\n    // hasn\'t asked us to abort\n    if((!(UEINTX & (1 << RXOUTI)))) {\n        // Clear the TXINI bit to initiate the transfer\n        // to send the remaining data we may have queued up\n        UEINTX &= ~(1 << TXINI);\n        // Wait for the ACK back from the host (RXOUTI set)\n        while (!(UEINTX & (1 << RXOUTI)));\n    }\n\n    // Clear the RXOUTI bit to acknowledge the packet\n    UEINTX &= ~(1 << RXOUTI);\n}\n')),(0,r.kt)("h3",{id:"descriptors"},"Descriptors"),(0,r.kt)("p",null,"USB Descriptors are a crucial part of USB enumeration and they are the mechanism by which the host learns about the device and it's capabilities. The descriptors are a data structure\nthat is sent to the host when requested via a ",(0,r.kt)("inlineCode",{parentName:"p"},"GET_DESCRIPTOR")," request. The most common descriptors are ",(0,r.kt)("inlineCode",{parentName:"p"},"Device"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Configuration"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Interface"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Endpoint"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," descriptors.\nThe host will request these descriptors, learning a bit more about the device each time, and use that information to inform it's next decision which might be to request more information\nor begin loading a driver for the device. Our descriptors are pretty basic at the moment since we don't actually implement any functionality on the device. Our basic descriptors and\ncommented explanations are below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"// USB descriptors (example, replace with your own)\nconst uint8_t PROGMEM DeviceDescriptor[] = {\n    0x12,       // bLength\n    0x01,       // bDescriptorType (Device == 1)\n    0x01, 0x01, // bcdUSB (USB 1.1 for Full Speed)\n    0x00,       // bDeviceClass (0 for composite device)\n    0x00,       // bDeviceSubClass\n    0x00,       // bDeviceProtocol\n    0x08,       // bMaxPacketSize0 (8 bytes)\n    0xad, 0xde, // idVendor (0xdead)\n    0xef, 0xbe, // idProduct (0xbeef)\n    0x01, 0x00, // bcdDevice (Device version)\n    0x01,       // iManufacturer (Index of manufacturer string descriptor)\n    0x02,       // iProduct (Index of product string descriptor)\n    0x03,       // iSerialNumber (Index of serial number string descriptor)\n    0x01        // bNumConfigurations (Number of configurations)\n};\n\nconst uint8_t PROGMEM ConfigDescriptor[] = {\n    0x09,       // bLength\n    0x02,       // bDescriptorType (Configuration == 2)\n    0x12, 0x00, // wTotalLength (Total length of configuration descriptor and sub-descriptors)\n    0x01,       // bNumInterfaces (Number of interfaces in this configuration)\n    0x01,       // bConfigurationValue (Configuration value, must be 1)\n    0x00,       // iConfiguration (Index of string descriptor for this configuration)\n    0x80,       // bmAttributes (Bus-powered, no remote wakeup)\n    0xFA,       // bMaxPower (Maximum power consumption, 500mA)\n    0x09,       // bLength = 0x09, length of descriptor in bytes\n    0x04,       // bDescriptorType = 0x04, (Interface == 4)\n    0x00,       // bInterfaceNumber = 0;\n    0x00,       // bAlternateSetting = 0;\n    0x00,       // bNumEndpoints = USB_Endpoints;\n    0xFF,       // bInterfaceClass = 0xFF, classcode: custome (0xFF)\n    0xFF,       // bInterfaceSubClass = 0xFF, subclasscode: custome (0xFF)\n    0xFF,       // bInterfaceProtocol = 0xFF, protocoll code: custome (0xFF)\n    0x00        // iInterface = 0, Index for string descriptor interface\n};\n\nconst uint8_t PROGMEM LanguageDescriptor[] = {\n    0x04,     // bLength - Length of sting language descriptor including this byte\n    0x03,     // bDescriptorType - (String == 3)\n    0x09,0x04 // wLANGID[x] - (0x0409 = English USA)\n};\n\nconst uint8_t PROGMEM ManufacturerStringDescriptor[] = {\n    24,         // bLength - Length of string descriptor (including this byte)\n    0x03,       // bDescriptorType - (String == 3)\n    'e',0x00,   // bString - Unicode Encoded String (16 Bit)\n    'v',0x00,\n    'e',0x00,\n    'r',0x00,\n    'y',0x00,\n    'd',0x00,\n    'a',0x00,\n    'y',0x00,\n    'd',0x00,\n    'e',0x00,\n    'v',0x00\n};\n\nconst uint8_t PROGMEM ProductStringDescriptor[] = {\n    40,         // bLength - Length of string descriptor (including this byte)\n    0x03,       // bDescriptorType - (String == 3)\n    'a',0x00,   // bString - Unicode Encoded String (16 Bit)\n    'v',0x00,\n    'r',0x00,\n    ' ',0x00,\n    'u',0x00,\n    's',0x00,\n    'b',0x00,\n    ' ',0x00,\n    'm',0x00,\n    'a',0x00,\n    'd',0x00,\n    'e',0x00,\n    ' ',0x00,\n    's',0x00,\n    'i',0x00,\n    'm',0x00,\n    'p',0x00,\n    'l',0x00,\n    'e',0x00,\n};\n\nconst uint8_t PROGMEM SerialStringDescriptor[] = {\n    0x0A,       // bLength - Length of string descriptor (including this byte)\n    0x03,       // bDescriptorType - (String == 3)\n    '2',0x00,   // bString - Unicode Encoded String (16 Bit)\n    '0',0x00,\n    '2',0x00,\n    '3',0x00\n};\n")),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,'That\'s it! We now have a device that will enumerate with the host and provide basic information about itself. In the next post we will add a bit more functionality\nto our device by adding handling for "Vendor specific" control transfers allowing us to read/write small amounts of data from/to the device. We will also demonstrate\na couple of different ways to write data to a USB device via Control transfers from a Host OS using C, NodeJS, and Python.'))}p.isMDXComponent=!0}}]);